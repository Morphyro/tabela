<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construtor Molecular </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        .atom-C { background-color: #909090; color: white; }
        .atom-H { background-color: #FFFFFF; color: #333; }
        .atom-O { background-color: #FF0D0D; color: white; }
        .atom-N { background-color: #3050F8; color: white; }
        .atom-S { background-color: #FFFF30; color: #333; }
        .atom-P { background-color: #FF8000; color: white; }
        .atom-F, .atom-Cl, .atom-Br, .atom-I { background-color: #1FF01F; color: #333; }
        
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        #renderCanvas {
            touch-action: none;
        }
        
        .sidebar-transition {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
        }
        
        .atom-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        .bond-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        .floating-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            transform: translateY(-100%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        /* Desabilitar seleção de texto em todo o webapp */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Permitir seleção apenas em campos de input */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        @media (max-width: 768px) {
            #sidebar {
                transform: translateX(-100%);
                width: 280px;
            }
            #sidebar.open {
                transform: translateX(0);
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Sidebar -->
        <div id="sidebar" class="bg-white w-92 shadow-xl flex flex-col border-r border-gray-200 absolute md:relative z-20 sidebar-transition">
            <div class="p-4 border-b border-gray-200 gradient-bg text-white flex justify-between items-center">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-atom text-xl"></i>
                    <h1 class="text-xl font-bold">Construtor Molecular</h1>
                </div>
                <button id="closeSidebar" class="md:hidden text-white hover:text-gray-200">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-4 space-y-6">
                <!-- Tools Section -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-tools mr-2 text-blue-600"></i> Ferramentas
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="selectTool" class="tool-btn active p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-mouse-pointer mb-1"></i>
                            <span class="text-xs">Selecionar</span>
                        </button>
                        <button id="atomTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-circle mb-1"></i>
                            <span class="text-xs">Átomo</span>
                        </button>
                        <button id="bondTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-link mb-1"></i>
                            <span class="text-xs">Ligação</span>
                        </button>
                        <button id="eraseTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-eraser mb-1"></i>
                            <span class="text-xs">Apagar</span>
                        </button>
                        <button id="rotateTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-sync-alt mb-1"></i>
                            <span class="text-xs">Rotacionar</span>
                        </button>
                        <button id="measureTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-ruler mb-1"></i>
                            <span class="text-xs">Medir</span>
                        </button>
                    </div>
                </div>
                
                <!-- Atom Palette -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-palette mr-2 text-blue-600"></i> Átomos
                    </h2>
                    <div class="grid grid-cols-5 gap-2">
                        <button data-atom="C" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-C flex items-center justify-center text-sm font-medium active">
                            C
                        </button>
                        <button data-atom="H" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-H flex items-center justify-center text-sm font-medium">
                            H
                        </button>
                        <button data-atom="O" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-O flex items-center justify-center text-sm font-medium">
                            O
                        </button>
                        <button data-atom="N" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-N flex items-center justify-center text-sm font-medium">
                            N
                        </button>
                        <button data-atom="S" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-S flex items-center justify-center text-sm font-medium">
                            S
                        </button>
                        <button data-atom="P" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-P flex items-center justify-center text-sm font-medium">
                            P
                        </button>
                        <button data-atom="F" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-F flex items-center justify-center text-sm font-medium">
                            F
                        </button>
                        <button data-atom="Cl" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-Cl flex items-center justify-center text-sm font-medium">
                            Cl
                        </button>
                        <button data-atom="Br" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-Br flex items-center justify-center text-sm font-medium">
                            Br
                        </button>
                        <button data-atom="I" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-I flex items-center justify-center text-sm font-medium">
                            I
                        </button>
                    </div>
                </div>
                
                <!-- Bond Types -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-link mr-2 text-blue-600"></i> Ligações
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button data-bond="1" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium active">
                             ─
                        </button>
                        <button data-bond="2" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium">
                             ═
                        </button>
                        <button data-bond="3" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium">
                            ≡
                        </button>
                    </div>
                </div>
                
                <!-- Formula Input -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-flask mr-2 text-blue-600"></i> Fórmula
                    </h2>
                    <div class="space-y-2">
                        <div class="flex">
                            <input id="formulaInput" type="text" placeholder="Ex: H2O, CH4, C6H6" 
                                class="flex-1 p-2 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <button id="parseFormulaBtn" class="p-2 bg-blue-600 text-white rounded-r-lg hover:bg-blue-700">
                                <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Molecule Actions -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-bolt mr-2 text-blue-600"></i> Ações
                    </h2>
                    <div class="space-y-2">
                        <button id="optimizeBtn" class="w-full p-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg hover:from-green-600 hover:to-green-700 transition-all flex items-center justify-center">
                            <i class="fas fa-magic mr-2"></i> Otimizar Geometria
                        </button>
                        <button id="clearBtn" class="w-full p-2 bg-gradient-to-r from-red-500 to-red-600 text-white rounded-lg hover:from-red-600 hover:to-red-700 transition-all flex items-center justify-center">
                            <i class="fas fa-trash mr-2"></i> Limpar Tudo
                        </button>
                        <button id="addHydrogensBtn" class="w-full p-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all flex items-center justify-center">
                            <i class="fas fa-plus-circle mr-2"></i> Adicionar Hidrogênios
                        </button>
                    </div>
                </div>
                
                <!-- Preset Molecules -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-vial mr-2 text-blue-600"></i> Modelos
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button data-mol="h2o" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            H₂O
                        </button>
                        <button data-mol="co2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            CO₂
                        </button>
                        <button data-mol="ch4" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            CH₄
                        </button>
                        <button data-mol="nh3" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            NH₃
                        </button>
                        <button data-mol="c2h4" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            C₂H₄
                        </button>
                        <button data-mol="c2h2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            C₂H₂
                        </button>
                        <button data-mol="o2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            O₂
                        </button>
                        <button data-mol="n2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            N₂
                        </button>
                        <button data-mol="hcl" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            HCl
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="p-4 border-t border-gray-200 text-xs text-gray-500">
                <p>Mol3D v1.0 - Ferramenta avançada de Modelagem Molecular S(i)S</p>            </div>
        </div>
        
        <!-- Main Content -->
        <div id="main-content" class="flex-1 flex flex-col">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm p-3 flex justify-between items-center border-b border-gray-200">
                <button id="menuBtn" class="md:hidden p-2 rounded-lg hover:bg-gray-100 transition-colors">
                    <i class="fas fa-bars text-gray-600"></i>
                </button>
                
                <div class="flex items-center space-x-4">
                                    <div id="status" class="text-sm font-medium text-gray-700 bg-blue-50 px-3 py-1 rounded-full">
                    <i class="fas fa-mouse-pointer mr-1"></i> Modo Seleção
                </div>
                <div id="measurement" class="text-sm font-medium text-white bg-blue-600 px-3 py-1 rounded-full hidden">
                    <i class="fas fa-ruler mr-1"></i> Distância: <span id="distanceValue">0.00</span> Å
                </div>
                </div>
                
                <div class="flex space-x-2">
                    <button id="toggleViewBtn" class="p-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition-colors tooltip" data-tooltip="Alternar Visualização 2D/3D">
                        <i class="fas fa-sync-alt mr-1"></i> <span class="text-sm">2D/3D</span>
                    </button>
                    <button id="fullscreenBtn" class="p-2 rounded-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Tela Cheia">
                        <i class="fas fa-expand text-gray-600"></i>
                    </button>
                    <button id="helpBtn" class="p-2 rounded-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Ajuda">
                        <i class="fas fa-question-circle text-gray-600"></i>
                    </button>
                </div>
            </div>
            
            <!-- Viewports Container -->
            <div class="flex-1 relative">
                <!-- 3D Viewport -->
                <div id="view3D" class="w-full h-full absolute inset-0">
                <div id="renderCanvas" class="w-full h-full"></div>
                </div>
                
                <!-- 2D Viewport -->
                <div id="view2D" class="w-full h-full absolute inset-0 hidden">
                    <canvas id="canvas2D" class="w-full h-full bg-white"></canvas>
                    
                    <!-- 2D Controls -->
                    <div class="absolute top-4 left-4 bg-white p-2 rounded-lg shadow-lg">
                        <div class="text-sm font-medium mb-2">Modo 2D</div>
                        <div class="flex space-x-2">
                            <button id="gridToggleBtn" class="p-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors text-xs">
                                <i class="fas fa-th"></i> Grade
                            </button>
                            <button id="snapToggleBtn" class="p-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors text-xs">
                                <i class="fas fa-magnet"></i> Imantar
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Floating controls -->
                <div class="absolute bottom-4 right-4 flex flex-col space-y-2">
                    <button id="zoomInBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Aumentar Zoom">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button id="zoomOutBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Diminuir Zoom">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button id="resetViewBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Resetar Visualização">
                        <i class="fas fa-home"></i>
                    </button>
                </div>
                
                <!-- Floating tooltip -->
                <div id="floatingTooltip" class="floating-tooltip"></div>
                
                <!-- Loading overlay -->
                <div id="loadingOverlay" class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-10">
                    <div class="bg-white p-6 rounded-xl shadow-2xl text-center max-w-xs">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                        <p class="text-gray-700 font-medium">Otimizando estrutura molecular...</p>
                        <p class="text-xs text-gray-500 mt-1">Isso pode levar alguns segundos</p>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Bar -->
            <div class="bg-white p-3 border-t border-gray-200 flex justify-between items-center">
                <div class="text-sm text-gray-600 flex items-center space-x-4">
                    <span class="flex items-center">
                        <i class="fas fa-atom mr-1 text-blue-600"></i> <span id="atomCount">0</span> átomos
                    </span>
                    <span class="flex items-center">
                        <i class="fas fa-link mr-1 text-blue-600"></i> <span id="bondCount">0</span> ligações
                    </span>
                </div>
                <div class="flex space-x-2">
                    <button id="exportPNGBtn" class="px-3 py-1 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors text-sm flex items-center">
                        <i class="fas fa-image mr-1"></i> PNG
                    </button>
                    <button id="exportOBJBtn" class="px-3 py-1 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors text-sm flex items-center">
                        <i class="fas fa-cube mr-1"></i> OBJ
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-30">
        <div class="bg-white rounded-xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
            <div class="p-4 border-b border-gray-200 flex justify-between items-center gradient-bg text-white rounded-t-xl">
                <h3 class="text-lg font-semibold flex items-center">
                    <i class="fas fa-question-circle mr-2"></i> Ajuda Mol3D
                </h3>
                <button id="closeHelpModal" class="text-white hover:text-gray-200">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="p-6">
                <div class="mb-6">
                    <h4 class="font-semibold mb-3 text-blue-600 flex items-center">
                        <i class="fas fa-mouse-pointer mr-2"></i> Controles Básicos
                    </h4>
                    <ul class="space-y-2">
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">1</span>
                            <span>Selecione átomos da paleta e clique para posicioná-los</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">2</span>
                            <span>Use a ferramenta de ligação para conectar átomos</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">3</span>
                            <span>Clique e arraste para rotacionar a molécula no espaço 3D</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">4</span>
                            <span>Use a roda do mouse ou gesto de pinça para zoom</span>
                        </li>
                    </ul>
                </div>
                
                <div class="mb-6">
                    <h4 class="font-semibold mb-3 text-blue-600 flex items-center">
                        <i class="fas fa-keyboard mr-2"></i> Atalhos de Teclado
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">A</div>
                            <div class="text-sm">Ferramenta Átomo</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">B</div>
                            <div class="text-sm">Ferramenta Ligação</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">E</div>
                            <div class="text-sm">Ferramenta Apagar</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">R</div>
                            <div class="text-sm">Ferramenta Rotacionar</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">M</div>
                            <div class="text-sm">Ferramenta Medir</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">S</div>
                            <div class="text-sm">Ferramenta Selecionar</div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-blue-50 border border-blue-100 rounded-lg p-4">
                    <h4 class="font-semibold mb-2 text-blue-600 flex items-center">
                        <i class="fas fa-lightbulb mr-2"></i> Dica
                    </h4>
                    <p class="text-sm text-gray-700">Use o botão "Otimizar Geometria" para ajustar automaticamente sua molécula com comprimentos e ângulos de ligação realistas.</p>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200 text-right">
                <button id="closeHelpModalBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                    Fechar
                </button>
            </div>
        </div>
    </div>

    <script>
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // UI State
            const state = {
                currentTool: 'select',
                currentAtom: 'C',
                currentBond: 1,
                selectedAtoms: [],
                tempBond: null,
                isDrawing: false,
                viewMode: '3D', // '2D' ou '3D'
                measurement: {
                    active: false,
                    points: [],
                    line: null
                },
                rotation: {
                    active: false,
                    startPoint: null,
                    center: new THREE.Vector3(0, 0, 0)
                },
                view2D: {
                    scale: 50, // Pixels por unidade
                    offsetX: 0,
                    offsetY: 0,
                    gridEnabled: true,
                    snapEnabled: true,
                    gridSize: 20,
                    atoms: [], // Átomos na visualização 2D
                    bonds: [], // Ligações na visualização 2D
                    selectedAtom: null,
                    isDragging: false,
                    startX: 0,
                    startY: 0
                }
            };
            
            // UI Elements
            const menuBtn = document.getElementById('menuBtn');
            const closeSidebar = document.getElementById('closeSidebar');
            const sidebar = document.getElementById('sidebar');
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const closeHelpModal = document.getElementById('closeHelpModal');
            const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
            const statusDisplay = document.getElementById('status');
            const measurementDisplay = document.getElementById('measurement');
            const distanceValue = document.getElementById('distanceValue');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const atomCount = document.getElementById('atomCount');
            const bondCount = document.getElementById('bondCount');
            const floatingTooltip = document.getElementById('floatingTooltip');
            
            // Formula input elements
            const formulaInput = document.getElementById('formulaInput');
            const parseFormulaBtn = document.getElementById('parseFormulaBtn');
            
            // View toggle elements
            const toggleViewBtn = document.getElementById('toggleViewBtn');
            const view3D = document.getElementById('view3D');
            const view2D = document.getElementById('view2D');
            const canvas2D = document.getElementById('canvas2D');
            const gridToggleBtn = document.getElementById('gridToggleBtn');
            const snapToggleBtn = document.getElementById('snapToggleBtn');
            
            // Initialize 2D canvas
            const ctx2D = canvas2D.getContext('2d');
            
            // Event listeners for 2D canvas
            canvas2D.addEventListener('mousedown', onCanvas2DMouseDown);
            canvas2D.addEventListener('mousemove', onCanvas2DMouseMove);
            canvas2D.addEventListener('mouseup', onCanvas2DMouseUp);
            canvas2D.addEventListener('wheel', onCanvas2DWheel);
            
            // Resize canvas to match display size
            function resizeCanvas() {
                const rect = canvas2D.getBoundingClientRect();
                canvas2D.width = rect.width;
                canvas2D.height = rect.height;
                
                // Centralizar a visualização
                state.view2D.offsetX = canvas2D.width / 2;
                state.view2D.offsetY = canvas2D.height / 2;
                
                // Redesenhar o canvas
                if (state.viewMode === '2D') {
                    draw2D();
                }
            }
            
            // Tool buttons
            const toolButtons = {
                select: document.getElementById('selectTool'),
                atom: document.getElementById('atomTool'),
                bond: document.getElementById('bondTool'),
                erase: document.getElementById('eraseTool'),
                rotate: document.getElementById('rotateTool'),
                measure: document.getElementById('measureTool')
            };
            
            // Atom buttons
            const atomButtons = document.querySelectorAll('.atom-btn');
            
            // Bond buttons
            const bondButtons = document.querySelectorAll('.bond-btn');
            
            // Action buttons
            const optimizeBtn = document.getElementById('optimizeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const addHydrogensBtn = document.getElementById('addHydrogensBtn');
            
            // View controls
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetViewBtn = document.getElementById('resetViewBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            // Molecule preset buttons
            const molButtons = document.querySelectorAll('.mol-btn');
            
            // Export buttons
            const exportPNGBtn = document.getElementById('exportPNGBtn');
            const exportOBJBtn = document.getElementById('exportOBJBtn');
            
            // Tooltip elements
            const tooltipElements = document.querySelectorAll('.tooltip');
            
            // Three.js scene setup
            const container = document.getElementById('renderCanvas');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add subtle blue rim light for better depth perception
            const rimLight = new THREE.DirectionalLight(0x3b82f6, 0.3);
            rimLight.position.set(-1, -1, -1);
            scene.add(rimLight);
            
            // Molecular data
            const molecules = {
                atoms: [],
                bonds: []
            };
            
            // Atom geometry and material
            const atomGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const atomMaterials = {
                'H': new THREE.MeshPhongMaterial({ color: 0x3498DB }),
                'C': new THREE.MeshPhongMaterial({ color: 0x555555 }),
                'O': new THREE.MeshPhongMaterial({ color: 0xFF5733 }),
                'N': new THREE.MeshPhongMaterial({ color: 0x2980B9 }),
                'S': new THREE.MeshPhongMaterial({ color: 0xffff30 }),
                'P': new THREE.MeshPhongMaterial({ color: 0xff8000 }),
                'F': new THREE.MeshPhongMaterial({ color: 0x1ff01f }),
                'Cl': new THREE.MeshPhongMaterial({ color: 0x1D8348 }),
                'Br': new THREE.MeshPhongMaterial({ color: 0x1ff01f }),
                'I': new THREE.MeshPhongMaterial({ color: 0x1ff01f })
            };
            
            // Bond geometry and material
            const bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const bondMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            // Raycaster for interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Initialize tooltips
            tooltipElements.forEach(el => {
                const tooltipText = el.getAttribute('data-tooltip');
                
                el.addEventListener('mouseenter', (e) => {
                    floatingTooltip.textContent = tooltipText;
                    floatingTooltip.style.left = `${e.clientX}px`;
                    floatingTooltip.style.top = `${e.clientY}px`;
                    floatingTooltip.style.opacity = '1';
                });
                
                el.addEventListener('mouseleave', () => {
                    floatingTooltip.style.opacity = '0';
                });
                
                el.addEventListener('mousemove', (e) => {
                    floatingTooltip.style.left = `${e.clientX}px`;
                    floatingTooltip.style.top = `${e.clientY}px`;
                });
            });
            
            // Event listeners for UI
            menuBtn.addEventListener('click', () => {
                sidebar.classList.add('open');
            });
            
            closeSidebar.addEventListener('click', () => {
                sidebar.classList.remove('open');
            });
            
            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            
            closeHelpModal.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });
            
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });
            
            // Fechar modal ao clicar fora
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.add('hidden');
                }
            });
            
            // Fechar sidebar ao clicar fora (mobile)
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768) { // Apenas no mobile
                    const sidebar = document.getElementById('sidebar');
                    const menuBtn = document.getElementById('menuBtn');
                    
                    // Se a sidebar está aberta e o clique não foi na sidebar nem no botão do menu
                    if (sidebar.classList.contains('open') && 
                        !sidebar.contains(e.target) && 
                        !menuBtn.contains(e.target)) {
                        sidebar.classList.remove('open');
                    }
                }
            });
            
            // Fechar sidebar ao clicar no canvas/área de trabalho (mobile)
            const renderCanvas = document.getElementById('renderCanvas');
            const canvas2DElement = document.getElementById('canvas2D');
            
            if (renderCanvas) {
                renderCanvas.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) { // Apenas no mobile
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar.classList.contains('open')) {
                            sidebar.classList.remove('open');
                        }
                    }
                });
            }
            
            if (canvas2DElement) {
                canvas2DElement.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) { // Apenas no mobile
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar.classList.contains('open')) {
                            sidebar.classList.remove('open');
                        }
                    }
                });
            }
            
            // Tool selection
            Object.keys(toolButtons).forEach(tool => {
                toolButtons[tool].addEventListener('click', () => {
                    setActiveTool(tool);
                });
            });
            
            function setActiveTool(tool) {
                state.currentTool = tool;
                
                // Update UI
                Object.values(toolButtons).forEach(btn => {
                    btn.classList.remove('active');
                });
                toolButtons[tool].classList.add('active');
                
                // Update status
                const toolNames = {
                    select: 'Seleção',
                    atom: 'Adicionar Átomo',
                    bond: 'Adicionar Ligação',
                    erase: 'Apagar',
                    rotate: 'Rotacionar',
                    measure: 'Medir'
                };
                
                const toolIcons = {
                    select: 'fa-mouse-pointer',
                    atom: 'fa-circle',
                    bond: 'fa-link',
                    erase: 'fa-eraser',
                    rotate: 'fa-sync-alt',
                    measure: 'fa-ruler'
                };
                
                statusDisplay.innerHTML = `<i class="fas ${toolIcons[tool]} mr-1"></i> ${toolNames[tool]} Mode`;
                
                // Configurar controles com base na ferramenta selecionada
                if (tool === 'rotate') {
                    // Ativar controles de câmera para rotação
                    controls.enabled = true;
                    controls.enableRotate = true;
                    controls.enablePan = true;
                    controls.enableZoom = true;
                } else if (tool === 'select') {
                    // Permitir apenas rotação no modo de seleção
                    controls.enabled = true;
                    controls.enableRotate = true;
                    controls.enablePan = false;
                    controls.enableZoom = true;
                } else {
                    // Desativar controles de câmera para outras ferramentas
                    controls.enabled = false;
                }
                
                // Reset measurement if not in measure mode
                if (tool !== 'measure') {
                    state.measurement.active = false;
                    state.measurement.points = [];
                    measurementDisplay.classList.add('hidden');
                }
            }
            
            // Atom selection
            atomButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentAtom = btn.dataset.atom;
                    
                    // Update UI
                    atomButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                                    // Show tooltip
                floatingTooltip.textContent = `Selecionado: ${btn.dataset.atom}`;
                    const rect = btn.getBoundingClientRect();
                    floatingTooltip.style.left = `${rect.left + rect.width/2}px`;
                    floatingTooltip.style.top = `${rect.top - 10}px`;
                    floatingTooltip.style.opacity = '1';
                    
                    setTimeout(() => {
                        floatingTooltip.style.opacity = '0';
                    }, 1000);
                });
            });
            
            // Bond selection
            bondButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentBond = parseInt(btn.dataset.bond);
                    
                    // Update UI
                    bondButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            
            // Molecule presets
            molButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const molType = btn.dataset.mol;
                    loadMoleculePreset(molType);
                });
            });
            
            function loadMoleculePreset(type) {
                clearMolecule();
                
                switch(type) {
                    case 'h2o':
                        // Água (H2O)
                        addAtom('O', 0, 0, 0);
                        addAtom('H', 0.76, 0.5, 0);
                        addAtom('H', -0.76, 0.5, 0);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        break;
                    case 'co2':
                        // Dióxido de Carbono (CO2)
                        addAtom('C', 0, 0, 0);
                        addAtom('O', -1.16, 0, 0);
                        addAtom('O', 1.16, 0, 0);
                        addBond(0, 1, 2);
                        addBond(0, 2, 2);
                        break;
                    case 'ch4':
                        // Metano (CH4)
                        addAtom('C', 0, 0, 0);
                        addAtom('H', -0.63, -0.63, -0.63);
                        addAtom('H', 0.63, -0.63, 0.63);
                        addAtom('H', -0.63, 0.63, 0.63);
                        addAtom('H', 0.63, 0.63, -0.63);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        addBond(0, 4, 1);
                        break;
                    case 'nh3':
                        // Amoníaco (NH3)
                        addAtom('N', 0, 0, 0);
                        addAtom('H', -0.94, -0.33, 0);
                        addAtom('H', 0.47, -0.33, -0.81);
                        addAtom('H', 0.47, -0.33, 0.81);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        break;
                    case 'c2h4':
                        // Etileno (C2H4)
                        addAtom('C', -0.67, 0, 0);
                        addAtom('C', 0.67, 0, 0);
                        addAtom('H', -1.24, -0.93, 0);
                        addAtom('H', -1.24, 0.93, 0);
                        addAtom('H', 1.24, -0.93, 0);
                        addAtom('H', 1.24, 0.93, 0);
                        addBond(0, 1, 2);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        addBond(1, 4, 1);
                        addBond(1, 5, 1);
                        break;
                    case 'c2h2':
                        // Acetileno (C2H2)
                        addAtom('C', -0.6, 0, 0);
                        addAtom('C', 0.6, 0, 0);
                        addAtom('H', -1.66, 0, 0);
                        addAtom('H', 1.66, 0, 0);
                        addBond(0, 1, 3);
                        addBond(0, 2, 1);
                        addBond(1, 3, 1);
                        break;
                    case 'o2':
                        // Oxigênio (O2)
                        addAtom('O', -0.6, 0, 0);
                        addAtom('O', 0.6, 0, 0);
                        addBond(0, 1, 2);
                        break;
                    case 'n2':
                        // Nitrogênio (N2)
                        addAtom('N', -0.55, 0, 0);
                        addAtom('N', 0.55, 0, 0);
                        addBond(0, 1, 3);
                        break;
                    case 'hcl':
                        // Ácido Clorídrico (HCl)
                        addAtom('H', -0.6, 0, 0);
                        addAtom('Cl', 0.6, 0, 0);
                        addBond(0, 1, 1);
                        break;
                }
                
                optimizeGeometry();
                updateCounts();
            }
            
            // Molecule actions
            optimizeBtn.addEventListener('click', optimizeGeometry);
            clearBtn.addEventListener('click', clearMolecule);
            addHydrogensBtn.addEventListener('click', addHydrogens);
            
            // View controls
            zoomInBtn.addEventListener('click', () => {
                camera.position.z -= 0.5;
            });
            
            zoomOutBtn.addEventListener('click', () => {
                camera.position.z += 0.5;
            });
            
            resetViewBtn.addEventListener('click', () => {
                camera.position.set(0, 0, 5);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Export
            exportPNGBtn.addEventListener('click', exportPNG);
            exportOBJBtn.addEventListener('click', exportOBJ);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        setActiveTool('atom');
                        break;
                    case 'b':
                        setActiveTool('bond');
                        break;
                    case 'e':
                        setActiveTool('erase');
                        break;
                    case 'r':
                        setActiveTool('rotate');
                        break;
                    case 'm':
                        setActiveTool('measure');
                        break;
                    case 's':
                        setActiveTool('select');
                        break;
                }
            });
            
            // Mouse/touch events
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Toggle view mode between 2D and 3D
            toggleViewBtn.addEventListener('click', toggleViewMode);
            
            function toggleViewMode() {
                if (state.viewMode === '3D') {
                    // Mudar para visualização 2D
                    state.viewMode = '2D';
                    view3D.classList.add('hidden');
                    view2D.classList.remove('hidden');
                    
                    // Inicializar o canvas 2D se for a primeira vez
                    resizeCanvas();
                    
                    // Converter moléculas 3D para 2D
                    convert3Dto2D();
                    
                    // Desenhar a visualização 2D
                    draw2D();
                    
                    // Atualizar o botão
                    toggleViewBtn.innerHTML = '<i class="fas fa-cube mr-1"></i> <span class="text-sm">3D</span>';
                } else {
                    // Mudar para visualização 3D
                    state.viewMode = '3D';
                    view2D.classList.add('hidden');
                    view3D.classList.remove('hidden');
                    
                    // Converter moléculas 2D para 3D
                    convert2Dto3D();
                    
                    // Atualizar o botão
                    toggleViewBtn.innerHTML = '<i class="fas fa-square mr-1"></i> <span class="text-sm">2D</span>';
                }
            }
            
            // Grid and snap toggle
            gridToggleBtn.addEventListener('click', () => {
                state.view2D.gridEnabled = !state.view2D.gridEnabled;
                gridToggleBtn.classList.toggle('bg-blue-500');
                gridToggleBtn.classList.toggle('text-white');
                draw2D();
            });
            
            snapToggleBtn.addEventListener('click', () => {
                state.view2D.snapEnabled = !state.view2D.snapEnabled;
                snapToggleBtn.classList.toggle('bg-blue-500');
                snapToggleBtn.classList.toggle('text-white');
            });
            
            // Functions for molecule manipulation
            function addAtom(element, x, y, z) {
                const atom = {
                    element: element,
                    position: new THREE.Vector3(x, y, z),
                    mesh: null
                };
                
                // Verificar se já existe um átomo muito próximo desta posição
                const minDistance = 0.5; // Distância mínima entre átomos
                const tooClose = molecules.atoms.some(existingAtom => {
                    const distance = existingAtom.position.distanceTo(atom.position);
                    return distance < minDistance;
                });
                
                // Se estiver muito próximo, ajustar a posição
                if (tooClose) {
                    // Adicionar pequeno deslocamento aleatório
                    x += (Math.random() - 0.5) * 0.5;
                    y += (Math.random() - 0.5) * 0.5;
                    z += (Math.random() - 0.5) * 0.5;
                    atom.position.set(x, y, z);
                }
                
                const material = atomMaterials[element] || atomMaterials['C'];
                const sphere = new THREE.Mesh(atomGeometry, material);
                sphere.position.set(x, y, z);
                sphere.userData.atomIndex = molecules.atoms.length;
                scene.add(sphere);
                
                // Adicionar rótulo do elemento como sprite
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'rgba(255, 255, 255, 0.7)';
                context.beginPath();
                context.arc(32, 32, 30, 0, Math.PI * 2);
                context.fill();
                context.fillStyle = '#000';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(element, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y + 0.5, z);
                sprite.scale.set(0.5, 0.5, 0.5);
                scene.add(sprite);
                
                atom.mesh = sphere;
                atom.sprite = sprite;
                molecules.atoms.push(atom);
                
                return molecules.atoms.length - 1;
            }
            
            function addBond(atom1Index, atom2Index, order = 1) {
                const atom1 = molecules.atoms[atom1Index];
                const atom2 = molecules.atoms[atom2Index];
                
                if (!atom1 || !atom2) return;
                
                // Check if bond already exists
                const existingBond = molecules.bonds.find(b => 
                    (b.atom1 === atom1Index && b.atom2 === atom2Index) || 
                    (b.atom1 === atom2Index && b.atom2 === atom1Index)
                );
                
                if (existingBond) {
                    // Update bond order if different
                    if (existingBond.order !== order) {
                        existingBond.order = order;
                        updateBondVisual(existingBond);
                    }
                    return;
                }
                
                const bond = {
                    atom1: atom1Index,
                    atom2: atom2Index,
                    order: order,
                    mesh: null
                };
                
                createBondVisual(bond);
                molecules.bonds.push(bond);
                
                return molecules.bonds.length - 1;
            }
            
            function createBondVisual(bond) {
                const atom1 = molecules.atoms[bond.atom1];
                const atom2 = molecules.atoms[bond.atom2];
                
                if (!atom1 || !atom2) return;
                
                // Calculate position and rotation for the bond cylinder
                const pos1 = atom1.position;
                const pos2 = atom2.position;
                
                const center = new THREE.Vector3();
                center.addVectors(pos1, pos2);
                center.multiplyScalar(0.5);
                
                const direction = new THREE.Vector3().subVectors(pos2, pos1);
                const length = direction.length();
                
                // Adjust length based on atom radii
                const adjustedLength = length - 0.8; // Subtract both atom radii
                
                // Grupo para conter todas as partes da ligação
                const bondGroup = new THREE.Group();
                bondGroup.position.copy(center);
                
                // Orientação do grupo
                bondGroup.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction.clone().normalize()
                );
                
                // Para ligações simples, apenas um cilindro
                if (bond.order === 1) {
                    const cylinderGeometry = new THREE.CylinderGeometry(0.1, 0.1, adjustedLength, 8);
                    const cylinder = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    bondGroup.add(cylinder);
                }
                // Para ligações duplas, dois cilindros lado a lado
                else if (bond.order === 2) {
                    const offset = 0.12;
                    const cylinderGeometry = new THREE.CylinderGeometry(0.07, 0.07, adjustedLength, 8);
                    
                    const cylinder1 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder1.position.x = offset;
                    bondGroup.add(cylinder1);
                    
                    const cylinder2 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder2.position.x = -offset;
                    bondGroup.add(cylinder2);
                }
                // Para ligações triplas, três cilindros
                else if (bond.order === 3) {
                    const offset = 0.15;
                    const cylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, adjustedLength, 8);
                    
                    const cylinder1 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    bondGroup.add(cylinder1);
                    
                    const cylinder2 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder2.position.x = offset;
                    bondGroup.add(cylinder2);
                    
                    const cylinder3 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder3.position.x = -offset;
                    bondGroup.add(cylinder3);
                }
                
                scene.add(bondGroup);
                bond.mesh = bondGroup;
            }
            
            function updateBondVisual(bond) {
                if (bond.mesh) {
                    scene.remove(bond.mesh);
                }
                
                createBondVisual(bond);
            }
            
            function removeAtom(index) {
                if (index < 0 || index >= molecules.atoms.length) return;
                
                // Remove atom mesh
                const atom = molecules.atoms[index];
                if (atom.mesh) {
                    scene.remove(atom.mesh);
                }
                
                // Remove atom sprite label
                if (atom.sprite) {
                    scene.remove(atom.sprite);
                }
                
                // Remove all bonds connected to this atom
                const bondsToRemove = molecules.bonds.filter(b => 
                    b.atom1 === index || b.atom2 === index
                );
                
                bondsToRemove.forEach(bond => {
                    removeBond(molecules.bonds.indexOf(bond));
                });
                
                // Remove the atom from the array
                molecules.atoms.splice(index, 1);
                
                // Update indices in remaining atoms and bonds
                molecules.atoms.forEach((atom, i) => {
                    if (atom.mesh) {
                        atom.mesh.userData.atomIndex = i;
                    }
                });
                
                molecules.bonds.forEach(bond => {
                    if (bond.atom1 > index) bond.atom1--;
                    if (bond.atom2 > index) bond.atom2--;
                });
            }
            
            function removeBond(index) {
                if (index < 0 || index >= molecules.bonds.length) return;
                
                const bond = molecules.bonds[index];
                if (bond.mesh) {
                    scene.remove(bond.mesh);
                }
                
                molecules.bonds.splice(index, 1);
            }
            
            function clearMolecule() {
                // Remove all atoms and bonds
                molecules.atoms.forEach(atom => {
                    if (atom.mesh) {
                        scene.remove(atom.mesh);
                    }
                    if (atom.sprite) {
                        scene.remove(atom.sprite);
                    }
                });
                
                molecules.bonds.forEach(bond => {
                    if (bond.mesh) {
                        scene.remove(bond.mesh);
                    }
                });
                
                molecules.atoms = [];
                molecules.bonds = [];
                
                updateCounts();
            }
            
            function optimizeGeometry() {
                // Show loading overlay
                loadingOverlay.classList.remove('hidden');
                
                // Simular otimização (em um app real, usaria algoritmos de minimização de energia)
                setTimeout(() => {
                    // Aplicar forças de mola para ajustar comprimentos de ligação
                    for (let i = 0; i < 10; i++) { // Várias iterações para convergir
                        // Ajustar comprimentos de ligação
                        molecules.bonds.forEach(bond => {
                            const atom1 = molecules.atoms[bond.atom1];
                            const atom2 = molecules.atoms[bond.atom2];
                            
                            if (!atom1 || !atom2) return;
                            
                            // Determinar comprimento ideal para esta ligação baseado no tipo de ligação
                            let bondKey, idealLength;
                            
                            if (bond.order === 1) {
                                bondKey = `${atom1.element}-${atom2.element}`;
                                const reverseBondKey = `${atom2.element}-${atom1.element}`;
                                idealLength = molecularGeometry.bondLengths[bondKey] || 
                                            molecularGeometry.bondLengths[reverseBondKey] || 
                                            molecularGeometry.bondLengths.default;
                            } else if (bond.order === 2) {
                                bondKey = `${atom1.element}=${atom2.element}`;
                                const reverseBondKey = `${atom2.element}=${atom1.element}`;
                                idealLength = molecularGeometry.bondLengths[bondKey] || 
                                            molecularGeometry.bondLengths[reverseBondKey] || 
                                            molecularGeometry.bondLengths[`${atom1.element}-${atom2.element}`] * 0.9 || 
                                            molecularGeometry.bondLengths.default * 0.9;
                            } else if (bond.order === 3) {
                                bondKey = `${atom1.element}≡${atom2.element}`;
                                const reverseBondKey = `${atom2.element}≡${atom1.element}`;
                                idealLength = molecularGeometry.bondLengths[bondKey] || 
                                            molecularGeometry.bondLengths[reverseBondKey] || 
                                            molecularGeometry.bondLengths[`${atom1.element}-${atom2.element}`] * 0.8 || 
                                            molecularGeometry.bondLengths.default * 0.8;
                            }
                            
                            const direction = new THREE.Vector3().subVectors(atom2.position, atom1.position);
                            const currentLength = direction.length();
                            direction.normalize();
                            
                            // Calcular força baseada na diferença de comprimento
                            const forceMagnitude = (currentLength - idealLength) * 0.5;
                            const force = direction.clone().multiplyScalar(forceMagnitude);
                            
                            // Aplicar força em direções opostas
                            if (atom1.element !== 'H') { // Hidrogênios são mais leves
                                atom1.position.add(force);
                            }
                            
                            if (atom2.element !== 'H') {
                                atom2.position.sub(force);
                            }
                        });
                        
                        // Ajustar ângulos de ligação com base na hibridização
                        molecules.atoms.forEach((atom, atomIndex) => {
                            // Encontrar todas as ligações conectadas a este átomo
                            const connectedBonds = molecules.bonds.filter(bond => 
                                bond.atom1 === atomIndex || bond.atom2 === atomIndex
                            );
                            
                            // Determinar hibridização com base no número de ligações
                            const bondCount = connectedBonds.length;
                            const hybridization = determineHybridization(atom.element, bondCount);
                            
                            // Se tiver pelo menos 2 ligações, podemos ajustar ângulos
                            if (connectedBonds.length >= 2) {
                                // Determinar ângulo ideal com base na hibridização
                                let idealAngle;
                                
                                if (hybridization === 'sp3') {
                                    idealAngle = molecularGeometry.bondAngles.sp3;
                                } else if (hybridization === 'sp2') {
                                    idealAngle = molecularGeometry.bondAngles.sp2;
                                } else if (hybridization === 'sp') {
                                    idealAngle = molecularGeometry.bondAngles.sp;
                                } else if (hybridization === 'bent') {
                                    // Casos especiais para moléculas com geometria angular
                                    if (atom.element === 'O' && bondCount === 2) {
                                        idealAngle = molecularGeometry.bondAngles.bent.H2O;
                                    } else if (atom.element === 'N' && bondCount === 3) {
                                        idealAngle = molecularGeometry.bondAngles.bent.NH3;
                                    } else {
                                        idealAngle = molecularGeometry.bondAngles.bent.default;
                                    }
                                } else {
                                    idealAngle = molecularGeometry.bondAngles.sp3; // Padrão
                                }
                                
                                // Converter para radianos
                                idealAngle = idealAngle * Math.PI / 180;
                                
                                // Para cada par de ligações
                                for (let i = 0; i < connectedBonds.length; i++) {
                                    for (let j = i + 1; j < connectedBonds.length; j++) {
                                        const bond1 = connectedBonds[i];
                                        const bond2 = connectedBonds[j];
                                        
                                        // Obter os átomos conectados
                                        const otherAtomIndex1 = bond1.atom1 === atomIndex ? bond1.atom2 : bond1.atom1;
                                        const otherAtomIndex2 = bond2.atom1 === atomIndex ? bond2.atom2 : bond2.atom1;
                                        
                                        const otherAtom1 = molecules.atoms[otherAtomIndex1];
                                        const otherAtom2 = molecules.atoms[otherAtomIndex2];
                                        
                                        if (!otherAtom1 || !otherAtom2) continue;
                                        
                                        // Calcular vetores de ligação
                                        const vec1 = new THREE.Vector3().subVectors(otherAtom1.position, atom.position).normalize();
                                        const vec2 = new THREE.Vector3().subVectors(otherAtom2.position, atom.position).normalize();
                                        
                                        // Calcular ângulo atual
                                        const dotProduct = Math.max(-1, Math.min(1, vec1.dot(vec2))); // Limitar para evitar erros numéricos
                                        const currentAngle = Math.acos(dotProduct);
                                        
                                        // Ajustar se necessário
                                        if (Math.abs(currentAngle - idealAngle) > 0.1) {
                                            // Aplicar pequena rotação para aproximar do ângulo ideal
                                            const adjustment = (currentAngle - idealAngle) * 0.1;
                                            
                                            // Rotacionar em torno do eixo perpendicular
                                            const axis = new THREE.Vector3().crossVectors(vec1, vec2).normalize();
                                            
                                            if (axis.length() > 0.01) { // Evitar eixos de rotação inválidos
                                                // Aplicar rotação a um dos átomos (se não for H)
                                                if (otherAtom2.element !== 'H') {
                                                    const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axis, adjustment);
                                                    const relativePos = new THREE.Vector3().subVectors(otherAtom2.position, atom.position);
                                                    relativePos.applyMatrix4(rotationMatrix);
                                                    otherAtom2.position.copy(atom.position).add(relativePos);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Atualizar posições dos meshes
                    molecules.atoms.forEach(atom => {
                        if (atom.mesh) {
                            atom.mesh.position.copy(atom.position);
                        }
                    });
                    
                    // Atualizar ligações
                    molecules.bonds.forEach(bond => {
                        updateBondVisual(bond);
                    });
                    
                    // Hide loading overlay
                    loadingOverlay.classList.add('hidden');
                }, 1000);
            }
            
            function addHydrogens() {
                // Implementação avançada: adicionar hidrogênios com base nas regras de valência
                // e estrutura 3D da molécula
                
                // Mostrar overlay de carregamento
                loadingOverlay.classList.remove('hidden');
                
                setTimeout(() => {
                const newAtoms = [];
                
                    // Valências comuns para elementos
                    const valences = {
                        'C': 4,  // Carbono: 4 ligações
                        'N': 3,  // Nitrogênio: 3 ligações
                        'O': 2,  // Oxigênio: 2 ligações
                        'H': 1,  // Hidrogênio: 1 ligação
                        'F': 1,  // Flúor: 1 ligação
                        'Cl': 1, // Cloro: 1 ligação
                        'Br': 1, // Bromo: 1 ligação
                        'I': 1,  // Iodo: 1 ligação
                        'S': 2,  // Enxofre: geralmente 2 ligações (simplificado)
                        'P': 3,  // Fósforo: geralmente 3 ligações (simplificado)
                        'default': 1
                    };
                    
                    // Comprimentos ideais de ligação com hidrogênio
                    const hBondLengths = {
                        'C': 1.1,
                        'N': 1.0,
                        'O': 0.96,
                        'S': 1.3,
                        'P': 1.4,
                        'default': 1.1
                    };
                    
                    // Para cada átomo não-hidrogênio
                molecules.atoms.forEach((atom, i) => {
                        if (atom.element === 'H') return; // Pular hidrogênios
                    
                        // Contar ligações existentes e identificar átomos vizinhos
                        const connectedBonds = molecules.bonds.filter(b => 
                        b.atom1 === i || b.atom2 === i
                        );
                        
                        const connectedAtoms = connectedBonds.map(bond => {
                            const otherIndex = bond.atom1 === i ? bond.atom2 : bond.atom1;
                            return {
                                index: otherIndex,
                                atom: molecules.atoms[otherIndex],
                                bondOrder: bond.order
                            };
                        });
                        
                        // Calcular valência total usada (considerando ordens de ligação)
                        const usedValence = connectedBonds.reduce((sum, bond) => sum + bond.order, 0);
                        
                        // Determinar quantos hidrogênios adicionar
                        const maxValence = valences[atom.element] || valences.default;
                        let hydrogensToAdd = Math.max(0, maxValence - usedValence);
                        
                        // Se for um carbono com ligação dupla ou tripla, ajustar geometria
                        let geometry = 'tetrahedral'; // Padrão para carbono sp3
                        
                        if (atom.element === 'C') {
                            if (connectedBonds.some(b => b.order === 2)) {
                                geometry = 'trigonal'; // sp2 (120°)
                            } else if (connectedBonds.some(b => b.order === 3)) {
                                geometry = 'linear'; // sp (180°)
                            }
                        } else if (atom.element === 'N' || atom.element === 'O') {
                            geometry = 'bent'; // Geometria angular
                        }
                        
                        // Adicionar hidrogênios com base na geometria
                        if (hydrogensToAdd > 0) {
                            // Determinar posições para os hidrogênios com base na geometria e átomos vizinhos
                            let positions = [];
                            
                            // Comprimento de ligação para este elemento
                            const bondLength = hBondLengths[atom.element] || hBondLengths.default;
                            
                            // Calcular direções para evitar (direções de átomos já conectados)
                            const avoidDirections = connectedAtoms.map(connected => {
                                return new THREE.Vector3().subVectors(
                                    connected.atom.position,
                                    atom.position
                                ).normalize();
                            });
                            
                            // Gerar posições baseadas na geometria
                            switch (geometry) {
                                case 'tetrahedral': // sp3 - ângulo ~109.5°
                                    // Gerar pontos em um tetraedro
                                    positions = distributePointsOnTetrahedron(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'trigonal': // sp2 - ângulo 120°
                                    // Gerar pontos em um plano com ângulos de 120°
                                    positions = distributePointsOnTrigonal(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'linear': // sp - ângulo 180°
                                    // Gerar pontos em linha reta
                                    positions = distributePointsOnLine(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'bent': // Geometria angular (para O, N)
                                    // Ângulo aproximado de 104.5° para O, 107° para N
                                    const angle = atom.element === 'O' ? 104.5 : 107;
                                    positions = distributePointsOnBent(hydrogensToAdd, bondLength, avoidDirections, angle);
                            break;
                                    
                        default:
                                    // Distribuição uniforme na esfera
                                    positions = distributePointsOnSphere(hydrogensToAdd, bondLength);
                    }
                    
                            // Adicionar os hidrogênios nas posições calculadas
                        positions.forEach(pos => {
                            const hydrogenPos = atom.position.clone().add(pos);
                            const hIndex = addAtom('H', hydrogenPos.x, hydrogenPos.y, hydrogenPos.z);
                            addBond(i, hIndex, 1);
                            newAtoms.push(hIndex);
                        });
                    }
                });
                
                    // Otimizar geometria para espalhar novos hidrogênios
                if (newAtoms.length > 0) {
                    optimizeGeometry();
                    } else {
                        // Esconder overlay de carregamento se não houver otimização
                        loadingOverlay.classList.add('hidden');
                }
                
                updateCounts();
                }, 100);
            }
            
            // Funções auxiliares para distribuir hidrogênios em diferentes geometrias
            function distributePointsOnTetrahedron(count, radius, avoidDirections = []) {
                // Vértices de um tetraedro regular
                const tetrahedronVertices = [
                    new THREE.Vector3(1, 1, 1),
                    new THREE.Vector3(-1, -1, 1),
                    new THREE.Vector3(-1, 1, -1),
                    new THREE.Vector3(1, -1, -1)
                ];
                
                // Normalizar vértices
                tetrahedronVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = tetrahedronVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnTrigonal(count, radius, avoidDirections = []) {
                // Pontos em um plano com ângulos de 120°
                const trigonalVertices = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(-0.5, 0.866, 0),
                    new THREE.Vector3(-0.5, -0.866, 0)
                ];
                
                // Normalizar vértices
                trigonalVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = trigonalVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnLine(count, radius, avoidDirections = []) {
                // Pontos em linha reta (180°)
                const lineVertices = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(-1, 0, 0)
                ];
                
                // Normalizar vértices
                lineVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = lineVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnBent(count, radius, avoidDirections = [], angle = 104.5) {
                // Converter ângulo para radianos
                const angleRad = angle * Math.PI / 180;
                
                // Pontos em geometria angular
                const bentVertices = [
                    new THREE.Vector3(Math.sin(angleRad/2), Math.cos(angleRad/2), 0),
                    new THREE.Vector3(-Math.sin(angleRad/2), Math.cos(angleRad/2), 0)
                ];
                
                // Normalizar vértices
                bentVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = bentVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnSphere(count, radius, avoidDirections = []) {
                if (count <= 0) return [];
                
                // Gerar mais pontos do que o necessário para ter opções
                const candidateCount = Math.max(count * 3, 12);
                const candidates = [];
                const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle
                
                for (let i = 0; i < candidateCount; i++) {
                    const y = 1 - (i / (candidateCount - 1)) * 2;
                    const radiusAtY = Math.sqrt(1 - y * y);
                    
                    const theta = phi * i;
                    
                    const x = Math.cos(theta) * radiusAtY;
                    const z = Math.sin(theta) * radiusAtY;
                    
                    candidates.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
                }
                
                // Se não houver direções a evitar, retornar os pontos distribuídos uniformemente
                if (avoidDirections.length === 0 || count >= candidateCount) {
                    return candidates.slice(0, count);
                }
                
                // Filtrar candidatos para evitar direções específicas
                const filteredCandidates = candidates.filter(point => {
                    const direction = point.clone().normalize();
                    return !avoidDirections.some(dir => direction.dot(dir) > 0.8); // Ângulo < ~35°
                });
                
                // Se não houver candidatos suficientes após filtragem, adicionar pontos aleatórios
                if (filteredCandidates.length < count) {
                    while (filteredCandidates.length < count) {
                        // Gerar ponto aleatório na esfera
                        const randomPoint = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1
                        ).normalize().multiplyScalar(radius);
                        
                        // Verificar se não está muito próximo das direções a evitar
                        const direction = randomPoint.clone().normalize();
                        const tooClose = avoidDirections.some(dir => direction.dot(dir) > 0.7);
                        
                        if (!tooClose) {
                            filteredCandidates.push(randomPoint);
                        }
                    }
                }
                
                // Selecionar os pontos mais bem distribuídos
                // Para simplificar, vamos pegar os primeiros 'count' pontos
                return filteredCandidates.slice(0, count);
            }
            
            function updateCounts() {
                atomCount.textContent = molecules.atoms.length;
                bondCount.textContent = molecules.bonds.length;
            }
            
            // Viewport interaction
            function onMouseDown(event) {
                event.preventDefault();
                
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                
                // Verificar se está no modo de rotação
                if (state.currentTool === 'rotate') {
                    // Iniciar rotação manual
                    state.rotation.active = true;
                    state.rotation.startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    
                    // Verificar se clicou em algum átomo para rotacionar em torno dele
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    if (intersects.length > 0) {
                        const object = intersects[0].object;
                        if (object.userData.atomIndex !== undefined) {
                            // Usar o átomo como centro de rotação
                            const atom = molecules.atoms[object.userData.atomIndex];
                            if (atom) {
                                state.rotation.center.copy(atom.position);
                                
                                // Destacar o átomo como centro de rotação
                                atom.mesh.material.emissive.setHex(0x00ffff);
                                setTimeout(() => {
                                    atom.mesh.material.emissive.setHex(0x000000);
                                }, 500);
                            }
                        }
                    } else {
                        // Usar o centro da molécula como centro de rotação
                        state.rotation.center.set(0, 0, 0);
                    }
                } else {
                    // Para outras ferramentas, continuar com o comportamento normal
                handleInteraction();
                }
            }
            
            function onMouseMove(event) {
                // Atualizar posição do mouse independentemente do estado
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                
                // Se estiver no modo de rotação e rotação ativa
                if (state.currentTool === 'rotate' && state.rotation.active) {
                    // Calcular diferença de posição do mouse
                    const deltaX = event.clientX - state.rotation.startPoint.x;
                    const deltaY = event.clientY - state.rotation.startPoint.y;
                    
                    // Sensibilidade da rotação
                    const rotationSpeed = 0.01;
                    
                    // Criar quaternions para rotação
                    const quaternionX = new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(0, 1, 0), // Eixo Y para rotação horizontal
                        deltaX * rotationSpeed
                    );
                    
                    const quaternionY = new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(1, 0, 0), // Eixo X para rotação vertical
                        deltaY * rotationSpeed
                    );
                    
                    // Combinar rotações
                    const combinedQuaternion = new THREE.Quaternion().multiplyQuaternions(quaternionX, quaternionY);
                    
                    // Aplicar rotação a todos os átomos em relação ao centro
                    molecules.atoms.forEach(atom => {
                        if (!atom.mesh) return;
                        
                        // Calcular posição relativa ao centro de rotação
                        const relativePos = atom.position.clone().sub(state.rotation.center);
                        
                        // Aplicar rotação
                        relativePos.applyQuaternion(combinedQuaternion);
                        
                        // Calcular nova posição
                        const newPos = relativePos.add(state.rotation.center);
                        
                        // Atualizar posição
                        atom.position.copy(newPos);
                        atom.mesh.position.copy(newPos);
                    });
                    
                    // Atualizar ligações
                    molecules.bonds.forEach(bond => {
                        updateBondVisual(bond);
                    });
                    
                    // Atualizar ponto inicial para próxima rotação
                    state.rotation.startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
                // Se estiver desenhando uma ligação
                else if (state.currentTool === 'bond' && state.isDrawing && state.tempBond) {
                    // Atualizar posição da linha temporária
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Calcular ponto no espaço 3D
                    const planeNormal = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const plane = new THREE.Plane(planeNormal, -5);
                    const endPoint = new THREE.Vector3();
                    
                    if (raycaster.ray.intersectPlane(plane, endPoint)) {
                        // Atualizar a geometria da linha
                        const points = [state.tempBond.startPosition, endPoint];
                        state.tempBond.line.geometry.setFromPoints(points);
                        state.tempBond.line.computeLineDistances();
                        
                        // Verificar se está sobre outro átomo
                        const intersects = raycaster.intersectObjects(scene.children);
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData.atomIndex !== undefined && 
                                object.userData.atomIndex !== state.tempBond.startAtom) {
                                // Destacar átomo alvo
                                const atom = molecules.atoms[object.userData.atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x00ff00);
                                }
                                break;
                            }
                        }
                    }
                }
            }
            
            function onMouseUp(event) {
                // Verificar se está no modo de rotação
                if (state.currentTool === 'rotate' && state.rotation.active) {
                    // Finalizar rotação
                    state.rotation.active = false;
                    state.rotation.startPoint = null;
                    return;
                }
                
                // Se não estiver desenhando, não faz nada
                if (!state.isDrawing) return;
                
                // Finalizar desenho
                state.isDrawing = false;
                
                // Verificar se está no modo de ligação
                if (state.currentTool === 'bond' && state.tempBond) {
                    // Verificar se o mouse está sobre outro átomo
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    let foundAtom = false;
                    for (let i = 0; i < intersects.length; i++) {
                        const object = intersects[i].object;
                        if (object.userData.atomIndex !== undefined && 
                            object.userData.atomIndex !== state.tempBond.startAtom) {
                            
                            // Criar ligação entre os dois átomos
                            addBond(state.tempBond.startAtom, object.userData.atomIndex, state.currentBond);
                            updateCounts();
                            
                            // Remover destaque
                            const atom = molecules.atoms[object.userData.atomIndex];
                            if (atom && atom.mesh) {
                                atom.mesh.material.emissive.setHex(0x000000);
                            }
                            
                            foundAtom = true;
                            break;
                        }
                    }
                    
                    // Remover linha temporária
                    if (state.tempBond.line) {
                        scene.remove(state.tempBond.line);
                    }
                    
                    // Limpar seleção se não encontrou átomo
                    if (!foundAtom) {
                        state.selectedAtoms.forEach(idx => {
                            const atom = molecules.atoms[idx];
                            if (atom && atom.mesh) {
                                atom.mesh.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                    
                    state.tempBond = null;
                    state.selectedAtoms = [];
                }
            }
            
            function onTouchStart(event) {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;
                    
                    handleInteraction();
                }
            }
            
            function onTouchMove(event) {
                event.preventDefault();
                
                if (event.touches.length === 1 && state.isDrawing) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;
                    
                    if (state.currentTool === 'bond' && state.tempBond) {
                        // Update temporary bond position
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(scene.children);
                        
                        if (intersects.length > 0) {
                            const point = intersects[0].point;
                            state.tempBond.position.copy(point);
                        }
                    }
                }
            }
            
            function onTouchEnd(event) {
                event.preventDefault();
                state.isDrawing = false;
                
                if (state.currentTool === 'bond' && state.tempBond) {
                    // Remove temporary bond indicator
                    scene.remove(state.tempBond);
                    state.tempBond = null;
                }
            }
            
            function handleInteraction() {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    switch(state.currentTool) {
                        case 'select':
                            // Highlight selected atom
                            if (object.userData.atomIndex !== undefined) {
                                // Clear previous selection
                                state.selectedAtoms.forEach(index => {
                                    const atom = molecules.atoms[index];
                                    if (atom && atom.mesh) {
                                        atom.mesh.material.emissive.setHex(0x000000);
                                    }
                                });
                                
                                state.selectedAtoms = [object.userData.atomIndex];
                                
                                // Highlight new selection
                                const atom = molecules.atoms[object.userData.atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x333333);
                                }
                            }
                            break;
                            
                        case 'atom':
                            // Add new atom at clicked position
                            const element = state.currentAtom;
                            const position = intersects[0].point;
                            addAtom(element, position.x, position.y, position.z);
                            updateCounts();
                            break;
                            
                        case 'bond':
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                
                                // Destacar o átomo selecionado
                                const atom = molecules.atoms[atomIndex];
                                if (atom && atom.mesh) {
                                    // Remover destaque anterior
                                    state.selectedAtoms.forEach(idx => {
                                        const prevAtom = molecules.atoms[idx];
                                        if (prevAtom && prevAtom.mesh) {
                                            prevAtom.mesh.material.emissive.setHex(0x000000);
                                        }
                                    });
                                    
                                    // Destacar o novo átomo
                                    atom.mesh.material.emissive.setHex(0x00ff00);
                                }
                                
                                if (state.selectedAtoms.length === 0) {
                                    // Primeiro átomo selecionado
                                    state.selectedAtoms = [atomIndex];
                                    
                                    // Criar indicador temporário de ligação
                                    const lineGeometry = new THREE.BufferGeometry();
                                    const lineMaterial = new THREE.LineDashedMaterial({
                                        color: 0x00ff00,
                                        dashSize: 0.2,
                                        gapSize: 0.1,
                                        linewidth: 2
                                    });
                                    
                                    // Inicializar com dois pontos iguais (será atualizado no mousemove)
                                    const points = [atom.position.clone(), atom.position.clone()];
                                    lineGeometry.setFromPoints(points);
                                    
                                    const line = new THREE.Line(lineGeometry, lineMaterial);
                                    line.computeLineDistances(); // Necessário para linhas tracejadas
                                    scene.add(line);
                                    
                                    state.tempBond = {
                                        line: line,
                                        startAtom: atomIndex,
                                        startPosition: atom.position.clone()
                                    };
                                    state.isDrawing = true;
                                    
                                } else if (state.selectedAtoms.length === 1 && 
                                          state.selectedAtoms[0] !== atomIndex) {
                                    // Segundo átomo selecionado - criar ligação
                                    addBond(state.selectedAtoms[0], atomIndex, state.currentBond);
                                    
                                    // Limpar seleção e remover linha temporária
                                    if (state.tempBond && state.tempBond.line) {
                                        scene.remove(state.tempBond.line);
                                    }
                                    state.tempBond = null;
                                    state.selectedAtoms = [];
                                    state.isDrawing = false;
                                    
                                    // Remover destaque
                                    atom.mesh.material.emissive.setHex(0x000000);
                                    
                                    updateCounts();
                                }
                            }
                            break;
                            
                        case 'erase':
                            // Verificar se clicou em um átomo
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                
                                // Destacar o átomo antes de remover (feedback visual)
                                const atom = molecules.atoms[atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0xff0000);
                                }
                                
                                // Pequeno atraso para mostrar o destaque antes de remover
                                setTimeout(() => {
                                    removeAtom(atomIndex);
                                updateCounts();
                                }, 100);
                            }
                            // Verificar se clicou em uma ligação
                            else {
                                // Percorrer todas as ligações para ver se alguma foi clicada
                                for (let i = 0; i < molecules.bonds.length; i++) {
                                    const bond = molecules.bonds[i];
                                    
                                    // Verificar se o objeto clicado é parte da ligação
                                    if (bond.mesh === object || 
                                        (bond.mesh && bond.mesh.children && 
                                         bond.mesh.children.includes(object))) {
                                        
                                        // Destacar a ligação antes de remover
                                        if (bond.mesh) {
                                            if (bond.mesh.children) {
                                                bond.mesh.children.forEach(child => {
                                                    if (child.material) {
                                                        child.material.emissive = new THREE.Color(0xff0000);
                                                    }
                                                });
                                            } else if (bond.mesh.material) {
                                                bond.mesh.material.emissive = new THREE.Color(0xff0000);
                                            }
                                        }
                                        
                                        // Pequeno atraso para mostrar o destaque antes de remover
                                        setTimeout(() => {
                                            removeBond(i);
                                            updateCounts();
                                        }, 100);
                                        
                                        break;
                                    }
                                }
                            }
                            break;
                            
                        case 'measure':
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                const atom = molecules.atoms[atomIndex];
                                
                                // Destacar o átomo selecionado
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x0000ff); // Azul para medição
                                }
                                
                                // Adicionar ponto à medição
                                state.measurement.active = true;
                                state.measurement.points.push({
                                    position: atom.position.clone(),
                                    atomIndex: atomIndex
                                });
                                
                                // Se já temos dois pontos, calcular a distância
                                if (state.measurement.points.length === 2) {
                                    // Calcular distância entre os dois pontos
                                    const distance = state.measurement.points[0].position.distanceTo(state.measurement.points[1].position);
                                    distanceValue.textContent = distance.toFixed(2);
                                    measurementDisplay.classList.remove('hidden');
                                    
                                    // Criar linha visual para mostrar a medição
                                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                        state.measurement.points[0].position,
                                        state.measurement.points[1].position
                                    ]);
                                    
                                    const lineMaterial = new THREE.LineDashedMaterial({
                                        color: 0x0000ff,
                                        dashSize: 0.2,
                                        gapSize: 0.1,
                                        linewidth: 2
                                    });
                                    
                                    // Remover linha de medição anterior, se existir
                                    if (state.measurement.line) {
                                        scene.remove(state.measurement.line);
                                    }
                                    
                                    const line = new THREE.Line(lineGeometry, lineMaterial);
                                    line.computeLineDistances();
                                    scene.add(line);
                                    
                                    // Armazenar linha para poder removê-la depois
                                    state.measurement.line = line;
                                    
                                    // Adicionar texto com a distância no meio da linha
                                    const midPoint = new THREE.Vector3().addVectors(
                                        state.measurement.points[0].position,
                                        state.measurement.points[1].position
                                    ).multiplyScalar(0.5);
                                    
                                    // Resetar pontos para próxima medição, mas manter a linha
                                    setTimeout(() => {
                                        // Remover destaque dos átomos
                                        state.measurement.points.forEach(point => {
                                            const atom = molecules.atoms[point.atomIndex];
                                            if (atom && atom.mesh) {
                                                atom.mesh.material.emissive.setHex(0x000000);
                                            }
                                        });
                                        
                                        // Limpar pontos para próxima medição
                                    state.measurement.points = [];
                                    }, 1000);
                                }
                            }
                            break;
                    }
                } else if (state.currentTool === 'atom') {
                    // Add atom in 3D space
                    const element = state.currentAtom;
                    
                    // Criar um plano perpendicular à direção da câmera para projetar o ponto no espaço 3D
                    const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const planeNormal = cameraDirection.clone();
                    
                    // Determinar a distância do plano
                    const planeDistance = 5; // Distância padrão para colocar átomos
                    const planeConstant = planeDistance * planeNormal.length();
                    const plane = new THREE.Plane(planeNormal, -planeConstant);
                    
                    // Calcular o ponto de interseção com o plano
                    const intersection = new THREE.Vector3();
                    const intersected = raycaster.ray.intersectPlane(plane, intersection);
                    
                    // Usar o ponto de interseção ou um ponto padrão
                    let position;
                    if (intersected) {
                        position = intersection;
                    } else {
                        // Calcular um ponto a uma distância fixa na direção do raio
                        position = new THREE.Vector3();
                        raycaster.ray.at(planeDistance, position);
                    }
                    
                    // Adicionar átomo na posição calculada
                    addAtom(element, position.x, position.y, position.z);
                    updateCounts();
                }
            }
            
            // Fullscreen
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    container.requestFullscreen().catch(err => {
                        console.error(`Erro ao tentar ativar tela cheia: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
            
            // Export functions
            function exportPNG() {
                // Temporarily hide UI elements
                const sidebar = document.getElementById('sidebar');
                const bottomBar = document.querySelector('.bg-white.p-3.border-t');
                sidebar.style.display = 'none';
                bottomBar.style.display = 'none';
                
                // Render scene without UI
                renderer.render(scene, camera);
                
                // Create download link
                const link = document.createElement('a');
                link.download = 'molecule.png';
                link.href = renderer.domElement.toDataURL('image/png');
                link.click();
                
                // Restore UI elements
                sidebar.style.display = '';
                bottomBar.style.display = '';
            }
            
            function exportOBJ() {
                // Simple OBJ export (would need more complete implementation for production)
                let objContent = "# Mol3D OBJ Export\n";
                let mtlContent = "# Mol3D MTL Export\n";
                
                // Add atoms as spheres (simplified as vertices)
                molecules.atoms.forEach((atom, i) => {
                    objContent += `v ${atom.position.x} ${atom.position.y} ${atom.position.z}\n`;
                    objContent += `usemtl material_${i}\n`;
                    objContent += `p ${i+1}\n`;
                    
                    // Material (simplified)
                    const color = atomMaterials[atom.element] ? atomMaterials[atom.element].color : atomMaterials['C'].color;
                    mtlContent += `newmtl material_${i}\n`;
                    mtlContent += `Kd ${color.r} ${color.g} ${color.b}\n`;
                });
                
                // Add bonds as lines (simplified)
                molecules.bonds.forEach((bond, i) => {
                    const atom1 = molecules.atoms[bond.atom1];
                    const atom2 = molecules.atoms[bond.atom2];
                    
                    if (atom1 && atom2) {
                        const v1 = molecules.atoms.length + i*2 + 1;
                        const v2 = molecules.atoms.length + i*2 + 2;
                        
                        // Add vertices for bond ends (adjusted for atom radii)
                        const dir = new THREE.Vector3().subVectors(atom2.position, atom1.position).normalize();
                        const start = atom1.position.clone().add(dir.clone().multiplyScalar(0.4));
                        const end = atom2.position.clone().sub(dir.clone().multiplyScalar(0.4));
                        
                        objContent += `v ${start.x} ${start.y} ${start.z}\n`;
                        objContent += `v ${end.x} ${end.y} ${end.z}\n`;
                        objContent += `usemtl bond_material\n`;
                        objContent += `l ${v1} ${v2}\n`;
                    }
                });
                
                // Bond material
                mtlContent += `newmtl bond_material\n`;
                mtlContent += `Kd 0.2 0.2 0.2\n`;
                
                // Combine into a single file
                const fullContent = `${objContent}\n# Materials\n${mtlContent}`;
                
                // Create download link
                const link = document.createElement('a');
                link.download = 'molecule.obj';
                link.href = URL.createObjectURL(new Blob([fullContent], { type: 'text/plain' }));
                link.click();
            }
            
            // Window resize handler
            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                
                // Redimensionar o canvas 2D também
                resizeCanvas();
            }
            
            // 2D Canvas Functions
            
            // Converter coordenadas do mundo para coordenadas de tela
            function worldToScreen(x, y) {
                return {
                    x: x * state.view2D.scale + state.view2D.offsetX,
                    y: y * state.view2D.scale + state.view2D.offsetY
                };
            }
            
            // Converter coordenadas de tela para coordenadas do mundo
            function screenToWorld(x, y) {
                return {
                    x: (x - state.view2D.offsetX) / state.view2D.scale,
                    y: (y - state.view2D.offsetY) / state.view2D.scale
                };
            }
            
            // Aplicar snap à grade
            function snapToGrid(x, y) {
                if (!state.view2D.snapEnabled) return { x, y };
                
                const gridSize = state.view2D.gridSize / state.view2D.scale;
                return {
                    x: Math.round(x / gridSize) * gridSize,
                    y: Math.round(y / gridSize) * gridSize
                };
            }
            
            // Desenhar a grade
            function drawGrid() {
                if (!state.view2D.gridEnabled) return;
                
                const gridSize = state.view2D.gridSize;
                const width = canvas2D.width;
                const height = canvas2D.height;
                
                ctx2D.strokeStyle = '#e5e7eb'; // Cor cinza claro
                ctx2D.lineWidth = 1;
                
                // Linhas verticais
                for (let x = state.view2D.offsetX % gridSize; x < width; x += gridSize) {
                    ctx2D.beginPath();
                    ctx2D.moveTo(x, 0);
                    ctx2D.lineTo(x, height);
                    ctx2D.stroke();
                }
                
                // Linhas horizontais
                for (let y = state.view2D.offsetY % gridSize; y < height; y += gridSize) {
                    ctx2D.beginPath();
                    ctx2D.moveTo(0, y);
                    ctx2D.lineTo(width, y);
                    ctx2D.stroke();
                }
                
                // Desenhar eixos centrais
                ctx2D.strokeStyle = '#9ca3af'; // Cinza médio
                ctx2D.lineWidth = 2;
                
                // Eixo X
                ctx2D.beginPath();
                ctx2D.moveTo(0, state.view2D.offsetY);
                ctx2D.lineTo(width, state.view2D.offsetY);
                ctx2D.stroke();
                
                // Eixo Y
                ctx2D.beginPath();
                ctx2D.moveTo(state.view2D.offsetX, 0);
                ctx2D.lineTo(state.view2D.offsetX, height);
                ctx2D.stroke();
            }
            
            // Desenhar um átomo no canvas 2D
            function drawAtom2D(atom) {
                const pos = worldToScreen(atom.x, atom.y);
                const radius = 20; // Tamanho do átomo em pixels
                
                // Determinar cor do átomo
                let color;
                switch (atom.element) {
                    case 'H': color = '#FFFFFF'; break;
                    case 'C': color = '#909090'; break;
                    case 'O': color = '#FF0D0D'; break;
                    case 'N': color = '#3050F8'; break;
                    case 'S': color = '#FFFF30'; break;
                    case 'P': color = '#FF8000'; break;
                    case 'F': case 'Cl': case 'Br': case 'I': color = '#1FF01F'; break;
                    default: color = '#909090';
                }
                
                // Desenhar círculo
                ctx2D.beginPath();
                ctx2D.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx2D.fillStyle = color;
                ctx2D.fill();
                ctx2D.strokeStyle = '#000000';
                ctx2D.lineWidth = 2;
                ctx2D.stroke();
                
                // Desenhar símbolo do elemento
                ctx2D.font = 'bold 16px Arial';
                ctx2D.fillStyle = atom.element === 'H' || atom.element === 'S' ? '#000000' : '#FFFFFF';
                ctx2D.textAlign = 'center';
                ctx2D.textBaseline = 'middle';
                ctx2D.fillText(atom.element, pos.x, pos.y);
                
                // Destacar se selecionado
                if (atom === state.view2D.selectedAtom) {
                    ctx2D.beginPath();
                    ctx2D.arc(pos.x, pos.y, radius + 5, 0, Math.PI * 2);
                    ctx2D.strokeStyle = '#3b82f6'; // Azul
                    ctx2D.lineWidth = 3;
                    ctx2D.stroke();
                }
            }
            
            // Desenhar uma ligação no canvas 2D
            function drawBond2D(bond) {
                const atom1 = state.view2D.atoms.find(a => a.id === bond.atom1);
                const atom2 = state.view2D.atoms.find(a => a.id === bond.atom2);
                
                if (!atom1 || !atom2) return;
                
                const pos1 = worldToScreen(atom1.x, atom1.y);
                const pos2 = worldToScreen(atom2.x, atom2.y);
                
                // Calcular vetor da ligação
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Normalizar vetor
                const nx = dx / length;
                const ny = dy / length;
                
                // Vetor perpendicular
                const px = -ny;
                const py = nx;
                
                // Desenhar ligação com base na ordem
                ctx2D.strokeStyle = '#333333';
                ctx2D.lineWidth = 8;
                
                if (bond.order === 1) {
                    // Ligação simples
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.stroke();
                } else if (bond.order === 2) {
                    // Ligação dupla
                    const offset = 6;
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x + px * offset, pos1.y + py * offset);
                    ctx2D.lineTo(pos2.x + px * offset, pos2.y + py * offset);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x - px * offset, pos1.y - py * offset);
                    ctx2D.lineTo(pos2.x - px * offset, pos2.y - py * offset);
                    ctx2D.stroke();
                } else if (bond.order === 3) {
                    // Ligação tripla
                    const offset = 8;
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x + px * offset, pos1.y + py * offset);
                    ctx2D.lineTo(pos2.x + px * offset, pos2.y + py * offset);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x - px * offset, pos1.y - py * offset);
                    ctx2D.lineTo(pos2.x - px * offset, pos2.y - py * offset);
                    ctx2D.stroke();
                }
            }
            
            // Desenhar a visualização 2D completa
            function draw2D() {
                // Limpar o canvas
                ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
                
                // Desenhar a grade
                drawGrid();
                
                // Desenhar ligações
                state.view2D.bonds.forEach(drawBond2D);
                
                // Desenhar átomos
                state.view2D.atoms.forEach(drawAtom2D);
                
                // Desenhar ligação temporária se estiver criando uma
                if (state.currentTool === 'bond' && state.isDrawing && state.view2D.selectedAtom) {
                    const pos1 = worldToScreen(state.view2D.selectedAtom.x, state.view2D.selectedAtom.y);
                    const pos2 = { x: state.view2D.mouseX, y: state.view2D.mouseY };
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.strokeStyle = '#00ff00';
                    ctx2D.lineWidth = 3;
                    ctx2D.setLineDash([5, 5]);
                    ctx2D.stroke();
                    ctx2D.setLineDash([]);
                }
            }
            
            // Encontrar átomo na posição do mouse
            function findAtomAt(x, y) {
                const radius = 20; // Raio de detecção em pixels
                
                for (let i = state.view2D.atoms.length - 1; i >= 0; i--) {
                    const atom = state.view2D.atoms[i];
                    const pos = worldToScreen(atom.x, atom.y);
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= radius) {
                        return atom;
                    }
                }
                
                return null;
            }
            
            // Adicionar átomo na visualização 2D
            function addAtom2D(element, x, y) {
                // Aplicar snap à grade se necessário
                const pos = snapToGrid(x, y);
                
                // Criar novo átomo
                const atom = {
                    id: Date.now() + Math.random(), // ID único
                    element: element,
                    x: pos.x,
                    y: pos.y,
                    z: 0 // Z é zero na visualização 2D
                };
                
                // Adicionar ao array de átomos
                state.view2D.atoms.push(atom);
                
                // Redesenhar o canvas
                draw2D();
                
                return atom;
            }
            
            // Adicionar ligação na visualização 2D
            function addBond2D(atom1, atom2, order) {
                // Verificar se já existe uma ligação entre estes átomos
                const existingBond = state.view2D.bonds.find(bond => 
                    (bond.atom1 === atom1.id && bond.atom2 === atom2.id) ||
                    (bond.atom1 === atom2.id && bond.atom2 === atom1.id)
                );
                
                if (existingBond) {
                    // Atualizar ordem da ligação existente
                    existingBond.order = order;
                } else {
                    // Criar nova ligação
                    const bond = {
                        atom1: atom1.id,
                        atom2: atom2.id,
                        order: order
                    };
                    
                    // Adicionar ao array de ligações
                    state.view2D.bonds.push(bond);
                }
                
                // Redesenhar o canvas
                draw2D();
            }
            
            // Manipuladores de eventos para o canvas 2D
            function onCanvas2DMouseDown(event) {
                const rect = canvas2D.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Armazenar posição inicial para arrastar
                state.view2D.startX = x;
                state.view2D.startY = y;
                state.view2D.mouseX = x;
                state.view2D.mouseY = y;
                
                // Verificar se clicou em um átomo
                const atom = findAtomAt(x, y);
                
                if (atom) {
                    // Clicou em um átomo
                    if (state.currentTool === 'select') {
                        // Selecionar o átomo
                        state.view2D.selectedAtom = atom;
                        state.view2D.isDragging = true;
                        draw2D();
                    } else if (state.currentTool === 'bond') {
                        if (!state.view2D.selectedAtom) {
                            // Primeiro átomo da ligação
                            state.view2D.selectedAtom = atom;
                            state.isDrawing = true;
                        } else if (state.view2D.selectedAtom !== atom) {
                            // Segundo átomo da ligação - criar ligação
                            addBond2D(state.view2D.selectedAtom, atom, state.currentBond);
                            state.view2D.selectedAtom = null;
                            state.isDrawing = false;
                        }
                    } else if (state.currentTool === 'erase') {
                        // Remover átomo
                        const index = state.view2D.atoms.indexOf(atom);
                        if (index !== -1) {
                            // Remover ligações conectadas a este átomo
                            state.view2D.bonds = state.view2D.bonds.filter(bond => 
                                bond.atom1 !== atom.id && bond.atom2 !== atom.id
                            );
                            
                            // Remover o átomo
                            state.view2D.atoms.splice(index, 1);
                            
                            // Limpar seleção se necessário
                            if (state.view2D.selectedAtom === atom) {
                                state.view2D.selectedAtom = null;
                            }
                            
                            draw2D();
                        }
                    }
                } else {
                    // Clicou em um espaço vazio
                    if (state.currentTool === 'atom') {
                        // Adicionar novo átomo
                        const worldPos = screenToWorld(x, y);
                        const newAtom = addAtom2D(state.currentAtom, worldPos.x, worldPos.y);
                        
                        // Se estiver desenhando uma ligação, conectar ao átomo anterior
                        if (state.isDrawing && state.view2D.selectedAtom) {
                            addBond2D(state.view2D.selectedAtom, newAtom, state.currentBond);
                            state.view2D.selectedAtom = newAtom; // Continuar a partir do novo átomo
                        } else {
                            state.view2D.selectedAtom = newAtom;
                        }
                    } else if (state.currentTool === 'select') {
                        // Desselecionar átomo atual
                        state.view2D.selectedAtom = null;
                        
                        // Iniciar arrasto do canvas
                        state.view2D.isDragging = true;
                        draw2D();
                    } else if (state.currentTool === 'bond') {
                        // Cancelar seleção de ligação
                        state.view2D.selectedAtom = null;
                        state.isDrawing = false;
                        draw2D();
                    }
                }
            }
            
            function onCanvas2DMouseMove(event) {
                const rect = canvas2D.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Atualizar posição do mouse
                state.view2D.mouseX = x;
                state.view2D.mouseY = y;
                
                if (state.view2D.isDragging) {
                    if (state.view2D.selectedAtom) {
                        // Arrastar átomo selecionado
                        const worldPos = screenToWorld(x, y);
                        const snappedPos = snapToGrid(worldPos.x, worldPos.y);
                        
                        state.view2D.selectedAtom.x = snappedPos.x;
                        state.view2D.selectedAtom.y = snappedPos.y;
                    } else {
                        // Arrastar o canvas (pan)
                        const dx = x - state.view2D.startX;
                        const dy = y - state.view2D.startY;
                        
                        state.view2D.offsetX += dx;
                        state.view2D.offsetY += dy;
                        
                        state.view2D.startX = x;
                        state.view2D.startY = y;
                    }
                    
                    draw2D();
                } else if (state.isDrawing && state.currentTool === 'bond') {
                    // Desenhar linha temporária para ligação
                    draw2D();
                }
            }
            
            function onCanvas2DMouseUp(event) {
                state.view2D.isDragging = false;
                
                // Se estiver no modo bond, manter o estado de desenho
                if (state.currentTool !== 'bond') {
                    state.isDrawing = false;
                }
            }
            
            function onCanvas2DWheel(event) {
                event.preventDefault();
                
                // Calcular fator de zoom
                const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                
                // Posição do mouse em coordenadas do mundo antes do zoom
                const mousePos = screenToWorld(event.offsetX, event.offsetY);
                
                // Aplicar zoom
                state.view2D.scale *= zoomFactor;
                
                // Ajustar offset para manter o ponto sob o cursor
                const newMousePos = screenToWorld(event.offsetX, event.offsetY);
                state.view2D.offsetX += (newMousePos.x - mousePos.x) * state.view2D.scale;
                state.view2D.offsetY += (newMousePos.y - mousePos.y) * state.view2D.scale;
                
                draw2D();
            }
            
            // Funções para converter entre visualizações 2D e 3D
            
            // Converter moléculas 3D para 2D
            function convert3Dto2D() {
                // Limpar arrays 2D
                state.view2D.atoms = [];
                state.view2D.bonds = [];
                
                // Converter átomos
                molecules.atoms.forEach(atom => {
                    // Projetar coordenadas 3D para o plano XY
                    state.view2D.atoms.push({
                        id: atom.mesh.userData.atomIndex, // Usar o índice como ID
                        element: atom.element,
                        x: atom.position.x,
                        y: atom.position.y,
                        z: 0 // Ignorar coordenada Z para visualização 2D
                    });
                });
                
                // Converter ligações
                molecules.bonds.forEach(bond => {
                    state.view2D.bonds.push({
                        atom1: bond.atom1,
                        atom2: bond.atom2,
                        order: bond.order
                    });
                });
            }
            
            // Converter moléculas 2D para 3D
            function convert2Dto3D() {
                // Limpar a cena 3D
                clearMolecule();
                
                // Mapear IDs de átomos 2D para índices 3D
                const atomMap = new Map();
                
                // Adicionar átomos
                state.view2D.atoms.forEach(atom2D => {
                    // Criar átomo 3D com as coordenadas do átomo 2D
                    const index = addAtom(atom2D.element, atom2D.x, atom2D.y, 0);
                    atomMap.set(atom2D.id, index);
                });
                
                // Adicionar ligações
                state.view2D.bonds.forEach(bond2D => {
                    // Obter índices 3D correspondentes
                    const atom1Index = atomMap.get(bond2D.atom1);
                    const atom2Index = atomMap.get(bond2D.atom2);
                    
                    // Adicionar ligação 3D
                    if (atom1Index !== undefined && atom2Index !== undefined) {
                        addBond(atom1Index, atom2Index, bond2D.order);
                    }
                });
                
                // Otimizar a geometria para dar profundidade à molécula
                optimizeGeometry();
                
                // Atualizar contagens
                updateCounts();
            }
            
            // Função para verificar proximidade entre átomos e sugerir ligações
            function checkAtomProximity() {
                // Distâncias ideais para ligações entre diferentes elementos
                const bondDistances = {
                    'C-C': 1.5,
                    'C-H': 1.1,
                    'C-O': 1.4,
                    'C-N': 1.4,
                    'O-H': 1.0,
                    'N-H': 1.0,
                    'default': 1.5
                };
                
                // Tolerância para sugerir ligação
                const tolerance = 0.7; // 70% de tolerância
                
                // Limpar sugestões anteriores
                scene.children.forEach(obj => {
                    if (obj.userData && obj.userData.isSuggestion) {
                        scene.remove(obj);
                    }
                });
                
                // Só verificar se estiver no modo de ligação
                if (state.currentTool === 'bond') {
                    // Para cada par de átomos
                    for (let i = 0; i < molecules.atoms.length; i++) {
                        for (let j = i + 1; j < molecules.atoms.length; j++) {
                            const atom1 = molecules.atoms[i];
                            const atom2 = molecules.atoms[j];
                            
                            // Verificar se já existe ligação
                            const existingBond = molecules.bonds.find(b => 
                                (b.atom1 === i && b.atom2 === j) || 
                                (b.atom1 === j && b.atom2 === i)
                            );
                            
                            if (existingBond) continue;
                            
                            // Calcular distância
                            const distance = atom1.position.distanceTo(atom2.position);
                            
                            // Determinar distância ideal para esta combinação
                            const bondKey = `${atom1.element}-${atom2.element}`;
                            const reverseBondKey = `${atom2.element}-${atom1.element}`;
                            const idealDistance = bondDistances[bondKey] || 
                                                bondDistances[reverseBondKey] || 
                                                bondDistances.default;
                            
                            // Se estiver próximo o suficiente, sugerir ligação
                            const maxDistance = idealDistance * (1 + tolerance);
                            if (distance <= maxDistance) {
                                // Criar linha tracejada para sugerir ligação
                                const material = new THREE.LineDashedMaterial({
                                    color: 0x00ff00,
                                    dashSize: 0.1,
                                    gapSize: 0.05,
                                    opacity: 0.5,
                                    transparent: true
                                });
                                
                                const geometry = new THREE.BufferGeometry().setFromPoints([
                                    atom1.position,
                                    atom2.position
                                ]);
                                
                                const line = new THREE.Line(geometry, material);
                                line.computeLineDistances(); // Necessário para linhas tracejadas
                                line.userData = { 
                                    isSuggestion: true,
                                    atom1: i,
                                    atom2: j
                                };
                                scene.add(line);
                                
                                // Se o usuário clicar, criar a ligação
                                if (state.selectedAtoms.length === 1 && 
                                    (state.selectedAtoms[0] === i || state.selectedAtoms[0] === j)) {
                                    const otherAtom = state.selectedAtoms[0] === i ? j : i;
                                    addBond(state.selectedAtoms[0], otherAtom, state.currentBond);
                                    state.selectedAtoms = [];
                                    updateCounts();
                                }
                            }
                        }
                    }
                }
            }
            
            // Dados de geometria molecular baseados em hibridização
            const molecularGeometry = {
                // Ângulos de ligação em graus
                bondAngles: {
                    'sp3': 109.5,  // Tetraédrico (ex: C em metano)
                    'sp2': 120,    // Trigonal planar (ex: C em eteno)
                    'sp': 180,     // Linear (ex: C em etino)
                    'bent': {
                        'H2O': 104.5,  // Ângulo H-O-H na água
                        'NH3': 107,    // Ângulo H-N-H na amônia
                        'default': 109.5
                    }
                },
                
                // Comprimentos de ligação em Angstroms (convertidos para unidades Three.js)
                bondLengths: {
                    'C-C': 1.54,
                    'C=C': 1.34,
                    'C≡C': 1.20,
                    'C-H': 1.09,
                    'C-O': 1.43,
                    'C=O': 1.23,
                    'C-N': 1.47,
                    'C=N': 1.38,
                    'C≡N': 1.16,
                    'O-H': 0.96,
                    'N-H': 1.01,
                    'H-H': 0.74,
                    'O=O': 1.2,
                    'N≡N': 1.1,
                    'H-Cl': 1.3,
                    'default': 1.5
                },
                
                // Raios atômicos em Angstroms (convertidos para unidades Three.js)
                atomicRadii: {
                    'H': 0.25,
                    'C': 0.70,
                    'N': 0.65,
                    'O': 0.60,
                    'F': 0.50,
                    'P': 1.00,
                    'S': 1.00,
                    'Cl': 1.00,
                    'Br': 1.15,
                    'I': 1.40,
                    'default': 0.70
                }
            };
            
            // Parser de fórmulas químicas
            function parseChemicalFormula(formula) {
                // Remover espaços e normalizar
                formula = formula.trim().replace(/\s+/g, '');
                
                // Verificar se é uma fórmula conhecida dos presets
                const knownFormulas = {
                    'H2O': 'h2o',
                    'CO2': 'co2',
                    'CH4': 'ch4',
                    'NH3': 'nh3',
                    'C2H4': 'c2h4',
                    'C2H2': 'c2h2',
                    'O2': 'o2',
                    'N2': 'n2',
                    'HCl': 'hcl',
                    'HCL': 'hcl'
                };
                
                // Se for uma fórmula conhecida, usar o preset correspondente
                if (knownFormulas[formula]) {
                    loadMoleculePreset(knownFormulas[formula]);
                    return [];
                }
                
                // Expressão regular para identificar elementos e quantidades
                const elementRegex = /([A-Z][a-z]*)(\d*)/g;
                
                // Array para armazenar os elementos e suas quantidades
                const elements = [];
                let match;
                
                // Encontrar todos os elementos e suas quantidades
                while ((match = elementRegex.exec(formula)) !== null) {
                    const element = match[1];
                    const count = match[2] ? parseInt(match[2]) : 1;
                    elements.push({ element, count });
                }
                
                return elements;
            }
            
            // Determinar hibridização com base nas ligações
            function determineHybridization(element, bondCount) {
                if (element === 'C') {
                    if (bondCount === 4) return 'sp3';
                    if (bondCount === 3) return 'sp2';
                    if (bondCount === 2) return 'sp';
                } else if (element === 'N') {
                    if (bondCount === 3) return 'sp3';
                    if (bondCount === 2) return 'sp2';
                    if (bondCount === 1) return 'sp';
                } else if (element === 'O') {
                    if (bondCount === 2) return 'bent';
                    if (bondCount === 1) return 'sp3';
                }
                
                // Padrão para outros elementos
                return 'sp3';
            }
            
            // Construir molécula a partir de uma fórmula
            function buildMoleculeFromFormula(formula) {
                // Limpar molécula atual
                clearMolecule();
                
                // Mostrar overlay de carregamento
                loadingOverlay.classList.remove('hidden');
                
                // Parsear a fórmula
                const elements = parseChemicalFormula(formula);
                
                // Se parseChemicalFormula já carregou um preset, não precisamos fazer mais nada
                if (elements.length === 0) {
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Verificar se a fórmula é válida
                if (elements.length === 0) {
                    alert('Fórmula inválida. Por favor, insira uma fórmula química válida.');
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Tentar identificar moléculas conhecidas para estruturas específicas
                const knownMolecules = {
                    'H2O': buildWaterMolecule,
                    'NH3': buildAmmoniaMolecule,
                    'CH4': buildMethaneMolecule,
                    'C2H4': buildEtheneMolecule,
                    'C2H2': buildEthyneMolecule,
                    'C6H6': buildBenzeneMolecule,
                    'CO2': buildCarbonDioxideMolecule,
                    'O2': buildOxygenMolecule,
                    'N2': buildNitrogenMolecule,
                    'HCl': buildHydrogenChlorideMolecule
                };
                
                // Verificar se é uma molécula conhecida
                if (knownMolecules[formula]) {
                    knownMolecules[formula]();
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Para moléculas desconhecidas, construir uma estrutura genérica
                buildGenericMolecule(elements);
                
                // Otimizar a geometria
                setTimeout(() => {
                    optimizeGeometry();
                    loadingOverlay.classList.add('hidden');
                }, 500);
            }
            
            // Construir moléculas conhecidas com geometria precisa
            
            // Água (H2O) - Geometria angular
            function buildWaterMolecule() {
                // Átomo de oxigênio no centro
                const oIndex = addAtom('O', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria angular (104.5°)
                const angle = molecularGeometry.bondAngles.bent.H2O * Math.PI / 180;
                const bondLength = molecularGeometry.bondLengths['O-H'];
                
                const h1Index = addAtom('H', bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                const h2Index = addAtom('H', -bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                
                // Adicionar ligações
                addBond(oIndex, h1Index, 1);
                addBond(oIndex, h2Index, 1);
                
                updateCounts();
            }
            
            // Amônia (NH3) - Geometria piramidal
            function buildAmmoniaMolecule() {
                // Átomo de nitrogênio no centro
                const nIndex = addAtom('N', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria piramidal (107°)
                const angle = molecularGeometry.bondAngles.bent.NH3 * Math.PI / 180;
                const bondLength = molecularGeometry.bondLengths['N-H'];
                
                // Calcular coordenadas para uma pirâmide trigonal
                const h1Index = addAtom('H', 0, bondLength * Math.cos(angle/2), bondLength * Math.sin(angle/2));
                const h2Index = addAtom('H', bondLength * Math.sin(angle/2) * Math.cos(2*Math.PI/3), 
                                        bondLength * Math.cos(angle/2), 
                                        bondLength * Math.sin(angle/2) * Math.sin(2*Math.PI/3));
                const h3Index = addAtom('H', bondLength * Math.sin(angle/2) * Math.cos(4*Math.PI/3), 
                                        bondLength * Math.cos(angle/2), 
                                        bondLength * Math.sin(angle/2) * Math.sin(4*Math.PI/3));
                
                // Adicionar ligações
                addBond(nIndex, h1Index, 1);
                addBond(nIndex, h2Index, 1);
                addBond(nIndex, h3Index, 1);
                
                updateCounts();
            }
            
            // Metano (CH4) - Geometria tetraédrica
            function buildMethaneMolecule() {
                // Átomo de carbono no centro
                const cIndex = addAtom('C', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria tetraédrica (109.5°)
                const bondLength = molecularGeometry.bondLengths['C-H'];
                
                // Coordenadas para um tetraedro regular
                const tetrahedralCoords = [
                    new THREE.Vector3(bondLength, bondLength, bondLength),
                    new THREE.Vector3(-bondLength, -bondLength, bondLength),
                    new THREE.Vector3(-bondLength, bondLength, -bondLength),
                    new THREE.Vector3(bondLength, -bondLength, -bondLength)
                ];
                
                // Normalizar para o comprimento de ligação correto
                tetrahedralCoords.forEach(coord => coord.normalize().multiplyScalar(bondLength));
                
                // Adicionar átomos de hidrogênio
                const hIndices = tetrahedralCoords.map(coord => 
                    addAtom('H', coord.x, coord.y, coord.z)
                );
                
                // Adicionar ligações
                hIndices.forEach(hIndex => addBond(cIndex, hIndex, 1));
                
                updateCounts();
            }
            
            // Eteno (C2H4) - Geometria trigonal planar
            function buildEtheneMolecule() {
                // Comprimentos de ligação
                const ccLength = molecularGeometry.bondLengths['C=C'];
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono
                const c1Index = addAtom('C', -ccLength/2, 0, 0);
                const c2Index = addAtom('C', ccLength/2, 0, 0);
                
                // Átomos de hidrogênio para C1 (trigonal planar)
                const angle = molecularGeometry.bondAngles.sp2 * Math.PI / 180;
                const h1Index = addAtom('H', -ccLength/2 - chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                const h2Index = addAtom('H', -ccLength/2 - chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                
                // Átomos de hidrogênio para C2 (trigonal planar)
                const h3Index = addAtom('H', ccLength/2 + chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                const h4Index = addAtom('H', ccLength/2 + chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                
                // Adicionar ligações
                addBond(c1Index, c2Index, 2); // Ligação dupla
                addBond(c1Index, h1Index, 1);
                addBond(c1Index, h2Index, 1);
                addBond(c2Index, h3Index, 1);
                addBond(c2Index, h4Index, 1);
                
                updateCounts();
            }
            
            // Etino (C2H2) - Geometria linear
            function buildEthyneMolecule() {
                // Comprimentos de ligação
                const ccLength = molecularGeometry.bondLengths['C≡C'];
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono
                const c1Index = addAtom('C', -ccLength/2, 0, 0);
                const c2Index = addAtom('C', ccLength/2, 0, 0);
                
                // Átomos de hidrogênio (linear)
                const h1Index = addAtom('H', -ccLength/2 - chLength, 0, 0);
                const h2Index = addAtom('H', ccLength/2 + chLength, 0, 0);
                
                // Adicionar ligações
                addBond(c1Index, c2Index, 3); // Ligação tripla
                addBond(c1Index, h1Index, 1);
                addBond(c2Index, h2Index, 1);
                
                updateCounts();
            }
            
            // Benzeno (C6H6) - Anel aromático
            function buildBenzeneMolecule() {
                // Raio do anel
                const radius = 1.4;
                const ccLength = molecularGeometry.bondLengths['C=C'] * 1.1; // Ligeiramente maior para aromaticidade
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono no anel
                const cIndices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const cIndex = addAtom('C', radius * Math.cos(angle), radius * Math.sin(angle), 0);
                    cIndices.push(cIndex);
                }
                
                // Átomos de hidrogênio
                const hIndices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const hIndex = addAtom('H', (radius + chLength) * Math.cos(angle), (radius + chLength) * Math.sin(angle), 0);
                    hIndices.push(hIndex);
                }
                
                // Adicionar ligações no anel (alternando simples e duplas)
                for (let i = 0; i < 6; i++) {
                    const j = (i + 1) % 6;
                    addBond(cIndices[i], cIndices[j], i % 2 === 0 ? 2 : 1);
                }
                
                // Adicionar ligações C-H
                for (let i = 0; i < 6; i++) {
                    addBond(cIndices[i], hIndices[i], 1);
                }
                
                updateCounts();
            }
            
            // Dióxido de carbono (CO2) - Geometria linear
            function buildCarbonDioxideMolecule() {
                // Comprimento de ligação
                const coLength = molecularGeometry.bondLengths['C=O'];
                
                // Átomos
                const cIndex = addAtom('C', 0, 0, 0);
                const o1Index = addAtom('O', -coLength, 0, 0);
                const o2Index = addAtom('O', coLength, 0, 0);
                
                // Adicionar ligações duplas
                addBond(cIndex, o1Index, 2);
                addBond(cIndex, o2Index, 2);
                
                updateCounts();
            }
            
            // Oxigênio (O2) - Geometria linear
            function buildOxygenMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['O=O'] || 1.2;
                
                // Átomos
                const o1Index = addAtom('O', -bondLength/2, 0, 0);
                const o2Index = addAtom('O', bondLength/2, 0, 0);
                
                // Adicionar ligação dupla
                addBond(o1Index, o2Index, 2);
                
                updateCounts();
            }
            
            // Nitrogênio (N2) - Geometria linear
            function buildNitrogenMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['N≡N'] || 1.1;
                
                // Átomos
                const n1Index = addAtom('N', -bondLength/2, 0, 0);
                const n2Index = addAtom('N', bondLength/2, 0, 0);
                
                // Adicionar ligação tripla
                addBond(n1Index, n2Index, 3);
                
                updateCounts();
            }
            
            // Ácido Clorídrico (HCl) - Geometria linear
            function buildHydrogenChlorideMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['H-Cl'] || 1.3;
                
                // Átomos
                const hIndex = addAtom('H', -bondLength/2, 0, 0);
                const clIndex = addAtom('Cl', bondLength/2, 0, 0);
                
                // Adicionar ligação simples
                addBond(hIndex, clIndex, 1);
                
                updateCounts();
            }
            
            // Construir molécula genérica para fórmulas desconhecidas
            function buildGenericMolecule(elements) {
                // Posicionar o primeiro elemento no centro
                let centralElement = elements[0].element;
                let centralIndex = addAtom(centralElement, 0, 0, 0);
                
                // Posicionar os outros elementos ao redor do central
                let angleStep = 2 * Math.PI / (elements.length - 1);
                let radius = 1.5; // Distância padrão
                
                for (let i = 1; i < elements.length; i++) {
                    const element = elements[i].element;
                    const count = elements[i].count;
                    
                    // Determinar comprimento de ligação
                    const bondKey = `${centralElement}-${element}`;
                    const reverseBondKey = `${element}-${centralElement}`;
                    const bondLength = molecularGeometry.bondLengths[bondKey] || 
                                      molecularGeometry.bondLengths[reverseBondKey] || 
                                      molecularGeometry.bondLengths.default;
                    
                    // Adicionar átomos em círculo
                    for (let j = 0; j < count; j++) {
                        const angle = angleStep * (i-1) + (j * 2 * Math.PI / count);
                        const x = bondLength * Math.cos(angle);
                        const y = bondLength * Math.sin(angle);
                        const z = 0;
                        
                        const atomIndex = addAtom(element, x, y, z);
                        addBond(centralIndex, atomIndex, 1);
                    }
                }
                
                updateCounts();
            }
            
            // Event listener para o botão de parsear fórmula
            parseFormulaBtn.addEventListener('click', () => {
                const formula = formulaInput.value.trim();
                if (formula) {
                    buildMoleculeFromFormula(formula);
                }
            });
            
            // Event listener para tecla Enter no campo de fórmula
            formulaInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const formula = formulaInput.value.trim();
                    if (formula) {
                        buildMoleculeFromFormula(formula);
                    }
                }
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                
                // Verificar proximidade entre átomos para sugerir ligações
                checkAtomProximity();
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            animate();
            
            // Initial setup
            setActiveTool('select');
            updateCounts();
            
            // Load water molecule by default
            loadMoleculePreset('h2o');
        });
    </script>
</body>
</html>