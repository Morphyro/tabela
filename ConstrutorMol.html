<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construtor Molecular </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        .atom-C { background-color: #909090; color: white; }
        .atom-H { background-color: #FFFFFF; color: #333; }
        .atom-O { background-color: #FF0D0D; color: white; }
        .atom-N { background-color: #3050F8; color: white; }
        .atom-S { background-color: #FFFF30; color: #333; }
        .atom-P { background-color: #FF8000; color: white; }
        .atom-F, .atom-Cl, .atom-Br, .atom-I { background-color: #1FF01F; color: #333; }
        
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        #renderCanvas {
            touch-action: none;
        }
        
        .sidebar-transition {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
        }
        
        .atom-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        .bond-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        .floating-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            transform: translateY(-100%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        /* Desabilitar seleção de texto em todo o webapp */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Permitir seleção apenas em campos de input */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        @media (max-width: 768px) {
            #sidebar {
                transform: translateX(-100%);
                width: 280px;
            }
            #sidebar.open {
                transform: translateX(0);
            }
        }
        
        /* Context Menu Styles */
        .context-menu-item {
            transition: all 0.2s ease;
        }
        
        .context-menu-item:hover {
            background-color: #f3f4f6;
        }
        
        .context-menu-item:active {
            background-color: #e5e7eb;
        }
        
        #contextMenu {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
        }
        
        /* Atom Context Menu Styles */
        .atom-context-menu-item {
            transition: all 0.2s ease;
        }
        
        .atom-context-menu-item:hover {
            background-color: #f3f4f6;
        }
        
        .atom-context-menu-item:active {
            background-color: #e5e7eb;
        }
        
        #atomContextMenu {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Sidebar -->
        <div id="sidebar" class="bg-white w-92 shadow-xl flex flex-col border-r border-gray-200 absolute md:relative z-20 sidebar-transition">
            <div class="p-4 border-b border-gray-200 gradient-bg text-white flex justify-between items-center">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-atom text-xl"></i>
                    <h1 class="text-xl font-bold">Construtor Molecular</h1>
                </div>
                <button id="closeSidebar" class="md:hidden text-white hover:text-gray-200">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            

            <div class="flex-1 overflow-y-auto p-4 space-y-6">
                  <!-- Preset Molecules -->
                  <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-vial mr-2 text-blue-600"></i> Modelos
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button data-mol="h2o" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            H₂O
                        </button>
                        <button data-mol="co2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            CO₂
                        </button>
                        <button data-mol="ch4" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            CH₄
                        </button>
                        <button data-mol="nh3" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            NH₃
                        </button>
                        <button data-mol="c2h4" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            C₂H₄
                        </button>
                        <button data-mol="c2h2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            C₂H₂
                        </button>
                        <button data-mol="o2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            O₂
                        </button>
                        <button data-mol="n2" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            N₂
                        </button>
                        <button data-mol="hcl" class="mol-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center">
                            HCl
                        </button>
                    </div>
                </div>
                <!-- Tools Section -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-tools mr-2 text-blue-600"></i> Ferramentas
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="selectTool" class="tool-btn active p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-mouse-pointer mb-1"></i>
                            <span class="text-xs">Selecionar</span>
                        </button>
                        <button id="atomTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-circle mb-1"></i>
                            <span class="text-xs">Átomo</span>
                        </button>
                        <button id="moveTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-arrows-alt mb-1"></i>
                            <span class="text-xs">Mover</span>
                        </button>
                        <button id="bondTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-link mb-1"></i>
                            <span class="text-xs">Ligação</span>
                        </button>
                        <button id="eraseTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-eraser mb-1"></i>
                            <span class="text-xs">Apagar</span>
                        </button>
                        <button id="rotateTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-sync-alt mb-1"></i>
                            <span class="text-xs">Rotacionar</span>
                        </button>
                        <button id="measureTool" class="tool-btn p-2 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex flex-col items-center">
                            <i class="fas fa-ruler mb-1"></i>
                            <span class="text-xs">Medir</span>
                        </button>
                    </div>
                </div>
                
                <!-- Atom Palette -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-palette mr-2 text-blue-600"></i> Átomos
                    </h2>
                    <div class="grid grid-cols-5 gap-2">
                        <button data-atom="C" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-C flex items-center justify-center text-sm font-medium active">
                            C
                        </button>
                        <button data-atom="H" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-H flex items-center justify-center text-sm font-medium">
                            H
                        </button>
                        <button data-atom="O" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-O flex items-center justify-center text-sm font-medium">
                            O
                        </button>
                        <button data-atom="N" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-N flex items-center justify-center text-sm font-medium">
                            N
                        </button>
                        <button data-atom="S" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-S flex items-center justify-center text-sm font-medium">
                            S
                        </button>
                        <button data-atom="P" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-P flex items-center justify-center text-sm font-medium">
                            P
                        </button>
                        <button data-atom="F" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-F flex items-center justify-center text-sm font-medium">
                            F
                        </button>
                        <button data-atom="Cl" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-Cl flex items-center justify-center text-sm font-medium">
                            Cl
                        </button>
                        <button data-atom="Br" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-Br flex items-center justify-center text-sm font-medium">
                            Br
                        </button>
                        <button data-atom="I" class="atom-btn p-3 border border-gray-200 rounded-full hover:shadow-md transition-all atom-I flex items-center justify-center text-sm font-medium">
                            I
                        </button>
                    </div>
                </div>
                
                <!-- Bond Types -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-link mr-2 text-blue-600"></i> Ligações
                    </h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button data-bond="1" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium active">
                             ─
                        </button>
                        <button data-bond="2" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium">
                             ═
                        </button>
                        <button data-bond="3" class="bond-btn p-3 border border-gray-200 rounded-lg hover:bg-blue-50 transition-all flex items-center justify-center text-lg font-medium">
                            ≡
                        </button>
                    </div>
                </div>
                
                <!-- Formula Input -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-flask mr-2 text-blue-600"></i> Fórmula
                    </h2>
                    <div class="space-y-2">
                        <div class="flex">
                            <input id="formulaInput" type="text" placeholder="Ex: H2O, CH4, C6H6" 
                                class="flex-1 p-2 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <button id="parseFormulaBtn" class="p-2 bg-blue-600 text-white rounded-r-lg hover:bg-blue-700">
                                <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Molecule Actions -->
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                        <i class="fas fa-bolt mr-2 text-blue-600"></i> Ações
                    </h2>
                    <div class="space-y-2">
                        <button id="optimizeBtn" class="w-full p-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg hover:from-green-600 hover:to-green-700 transition-all flex items-center justify-center">
                            <i class="fas fa-magic mr-2"></i> Otimizar Geometria
                        </button>
                        <button id="clearBtn" class="w-full p-2 bg-gradient-to-r from-red-500 to-red-600 text-white rounded-lg hover:from-red-600 hover:to-red-700 transition-all flex items-center justify-center">
                            <i class="fas fa-trash mr-2"></i> Limpar Tudo
                        </button>
                        <button id="addHydrogensBtn" class="w-full p-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all flex items-center justify-center">
                            <i class="fas fa-plus-circle mr-2"></i> Adicionar Hidrogênios
                        </button>
                    </div>
                </div>
                
              
            </div>
            
            <div class="p-4 border-t border-gray-200 text-xs text-gray-500">
                <p>Mol3D v1.0 - Ferramenta avançada de Modelagem Molecular S(i)S</p>            </div>
        </div>
        
        <!-- Main Content -->
        <div id="main-content" class="flex-1 flex flex-col">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm p-3 flex justify-between items-center border-b border-gray-200">
                <button id="menuBtn" class="md:hidden p-2 rounded-lg hover:bg-gray-100 transition-colors">
                    <i class="fas fa-bars text-gray-600"></i>
                </button>
                
                <div class="flex items-center space-x-4">
                                    <div id="status" class="text-sm font-medium text-gray-700 bg-blue-50 px-3 py-1 rounded-full">
                    <i class="fas fa-mouse-pointer mr-1"></i>Seleção
                </div>
                <div id="measurement" class="text-sm font-medium text-white bg-blue-600 px-3 py-1 rounded-full hidden">
                    <i class="fas fa-ruler mr-1"></i> Distância: <span id="distanceValue">0.00</span> Å
                </div>
                </div>
                
                <div class="flex space-x-2">
                    <button id="toggleLabelsBtn" class="p-2 rounded-lg bg-green-500 text-white hover:bg-green-600 transition-colors tooltip" data-tooltip="Esconder/Mostrar Legendas">
                        <i class="fas fa-tags mr-1"></i> <span class="text-sm">Legendas</span>
                    </button>
                    <button id="toggleViewBtn" class="p-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition-colors tooltip" data-tooltip="Alternar Visualização 2D/3D">
                        <i class="fas fa-sync-alt mr-1"></i> <span class="text-sm">2D/3D</span>
                    </button>
                    <button id="fullscreenBtn" class="p-2 rounded-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Tela Cheia">
                        <i class="fas fa-expand text-gray-600"></i>
                    </button>
                    <button id="helpBtn" class="p-2 rounded-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Ajuda">
                        <i class="fas fa-question-circle text-gray-600"></i>
                    </button>
                </div>
            </div>
            
            <!-- Viewports Container -->
            <div class="flex-1 relative">
                <!-- 3D Viewport -->
                <div id="view3D" class="w-full h-full absolute inset-0">
                <div id="renderCanvas" class="w-full h-full"></div>
                </div>
                
                <!-- 2D Viewport -->
                <div id="view2D" class="w-full h-full absolute inset-0 hidden">
                    <canvas id="canvas2D" class="w-full h-full bg-white"></canvas>
                    
                    <!-- 2D Controls -->
                    <div class="absolute top-4 left-4 bg-white p-2 rounded-lg shadow-lg">
                        <div class="text-sm font-medium mb-2">Modo 2D</div>
                        <div class="flex space-x-2">
                            <button id="gridToggleBtn" class="p-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors text-xs">
                                <i class="fas fa-th"></i> Grade
                            </button>
                            <button id="snapToggleBtn" class="p-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors text-xs">
                                <i class="fas fa-magnet"></i> Imantar
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Floating controls -->
                <div class="absolute bottom-4 right-4 flex flex-col space-y-2">
                    <button id="zoomInBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Aumentar Zoom">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button id="zoomOutBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Diminuir Zoom">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button id="resetViewBtn" class="p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors tooltip" data-tooltip="Resetar Visualização">
                        <i class="fas fa-home"></i>
                    </button>
                </div>
                
                <!-- Floating tooltip -->
                <div id="floatingTooltip" class="floating-tooltip"></div>
                
                <!-- Context Menu -->
                <div id="contextMenu" class="absolute bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 hidden min-w-48">
                    <div class="px-4 py-2 text-sm font-semibold text-gray-700 border-b border-gray-100">
                        <i class="fas fa-tools mr-2"></i>Ferramentas
                    </div>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="select">
                        <i class="fas fa-mouse-pointer mr-3 text-gray-500"></i>Selecionar
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="atom">
                        <i class="fas fa-circle mr-3 text-gray-500"></i>Adicionar Átomo
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="move">
                        <i class="fas fa-arrows-alt mr-3 text-gray-500"></i>Mover Átomo
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="bond">
                        <i class="fas fa-link mr-3 text-gray-500"></i>Adicionar Ligação
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="erase">
                        <i class="fas fa-eraser mr-3 text-gray-500"></i>Apagar
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="rotate">
                        <i class="fas fa-sync-alt mr-3 text-gray-500"></i>Rotacionar
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-tool="measure">
                        <i class="fas fa-ruler mr-3 text-gray-500"></i>Medir
                    </button>
                    <div class="border-t border-gray-100 my-1"></div>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-action="optimize">
                        <i class="fas fa-magic mr-3 text-green-500"></i>Otimizar Geometria
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-action="addHydrogens">
                        <i class="fas fa-plus-circle mr-3 text-blue-500"></i>Adicionar Hidrogênios
                    </button>
                    <button class="context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-red-50 flex items-center" data-action="clear">
                        <i class="fas fa-trash mr-3 text-red-500"></i>Limpar Tudo
                    </button>
                </div>

                <!-- Atom Context Menu -->
                <div id="atomContextMenu" class="absolute bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 hidden min-w-48">
                    <div class="px-4 py-2 text-sm font-semibold text-gray-700 border-b border-gray-100">
                        <i class="fas fa-atom mr-2"></i>Átomo
                    </div>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-atom-action="select">
                        <i class="fas fa-mouse-pointer mr-3 text-gray-500"></i>Selecionar
                    </button>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-atom-action="move">
                        <i class="fas fa-arrows-alt mr-3 text-gray-500"></i>Mover
                    </button>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-atom-action="changeElement">
                        <i class="fas fa-exchange-alt mr-3 text-gray-500"></i>Alterar Elemento
                    </button>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-blue-50 flex items-center" data-atom-action="addBond">
                        <i class="fas fa-link mr-3 text-gray-500"></i>Adicionar Ligação
                    </button>
                    <div class="border-t border-gray-100 my-1"></div>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-red-50 flex items-center" data-atom-action="delete">
                        <i class="fas fa-trash mr-3 text-red-500"></i>Excluir Átomo
                    </button>
                    <button class="atom-context-menu-item w-full text-left px-4 py-2 text-sm hover:bg-orange-50 flex items-center" data-atom-action="deleteWithBonds">
                        <i class="fas fa-trash-alt mr-3 text-orange-500"></i>Excluir com Ligações
                    </button>
                </div>
                
                <!-- Loading overlay -->
                <div id="loadingOverlay" class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-10">
                    <div class="bg-white p-6 rounded-xl shadow-2xl text-center max-w-xs">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                        <p class="text-gray-700 font-medium">Otimizando estrutura molecular...</p>
                        <p class="text-xs text-gray-500 mt-1">Isso pode levar alguns segundos</p>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Bar -->
            <div class="bg-white p-3 border-t border-gray-200 flex justify-between items-center">
                <div class="text-sm text-gray-600 flex items-center space-x-4">
                    <span class="flex items-center">
                        <i class="fas fa-atom mr-1 text-blue-600"></i> <span id="atomCount">0</span> átomos
                    </span>
                    <span class="flex items-center">
                        <i class="fas fa-link mr-1 text-blue-600"></i> <span id="bondCount">0</span> ligações
                    </span>
                </div>
                <div class="flex space-x-2">
                    <button id="exportPNGBtn" class="px-3 py-1 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors text-sm flex items-center">
                        <i class="fas fa-image mr-1"></i> PNG
                    </button>
                    <button id="exportOBJBtn" class="px-3 py-1 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors text-sm flex items-center">
                        <i class="fas fa-cube mr-1"></i> OBJ
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-30">
        <div class="bg-white rounded-xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
            <div class="p-4 border-b border-gray-200 flex justify-between items-center gradient-bg text-white rounded-t-xl">
                <h3 class="text-lg font-semibold flex items-center">
                    <i class="fas fa-question-circle mr-2"></i> Ajuda Mol3D
                </h3>
                <button id="closeHelpModal" class="text-white hover:text-gray-200">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="p-6">
                <div class="mb-6">
                    <h4 class="font-semibold mb-3 text-blue-600 flex items-center">
                        <i class="fas fa-mouse-pointer mr-2"></i> Controles Básicos
                    </h4>
                    <ul class="space-y-2">
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">1</span>
                            <span>Selecione átomos da paleta e clique para posicioná-los</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">2</span>
                            <span>Use a ferramenta de ligação para conectar átomos</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">3</span>
                            <span>Clique e arraste para rotacionar a molécula no espaço 3D</span>
                        </li>
                        <li class="flex items-start">
                            <span class="bg-blue-100 text-blue-800 rounded-full w-5 h-5 flex items-center justify-center mr-2 mt-0.5 flex-shrink-0 text-xs">4</span>
                            <span>Use a roda do mouse ou gesto de pinça para zoom</span>
                        </li>
                    </ul>
                </div>
                
                <div class="mb-6">
                    <h4 class="font-semibold mb-3 text-blue-600 flex items-center">
                        <i class="fas fa-keyboard mr-2"></i> Atalhos de Teclado
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">A</div>
                            <div class="text-sm">Ferramenta Átomo</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">B</div>
                            <div class="text-sm">Ferramenta Ligação</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">E</div>
                            <div class="text-sm">Ferramenta Apagar</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">R</div>
                            <div class="text-sm">Ferramenta Rotacionar</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">M</div>
                            <div class="text-sm">Ferramenta Mover</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">D</div>
                            <div class="text-sm">Ferramenta Medir</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-mono bg-gray-200 px-2 py-1 rounded inline-block mb-1">S</div>
                            <div class="text-sm">Ferramenta Selecionar</div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-blue-50 border border-blue-100 rounded-lg p-4">
                    <h4 class="font-semibold mb-2 text-blue-600 flex items-center">
                        <i class="fas fa-lightbulb mr-2"></i> Dica
                    </h4>
                    <p class="text-sm text-gray-700">Use o botão "Otimizar Geometria" para ajustar automaticamente sua molécula com comprimentos e ângulos de ligação realistas.</p>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200 text-right">
                <button id="closeHelpModalBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                    Fechar
                </button>
            </div>
        </div>
    </div>

    <script>
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // UI State
            const state = {
                currentTool: 'select',
                currentAtom: 'C',
                currentBond: 1,
                selectedAtoms: [],
                tempBond: null,
                isDrawing: false,
                viewMode: '3D', // '2D' ou '3D'
                labelsVisible: true, // Controla visibilidade das legendas
                measurement: {
                    active: false,
                    points: [],
                    line: null
                },
                rotation: {
                    active: false,
                    startPoint: null,
                    center: new THREE.Vector3(0, 0, 0)
                },
                view2D: {
                    scale: 50, // Pixels por unidade
                    offsetX: 0,
                    offsetY: 0,
                    gridEnabled: true,
                    snapEnabled: true,
                    gridSize: 20,
                    atoms: [], // Átomos na visualização 2D
                    bonds: [], // Ligações na visualização 2D
                    selectedAtom: null,
                    isDragging: false,
                    startX: 0,
                    startY: 0
                },
                atomPreview: {
                    mesh: null,
                    bondPreview: null,
                    targetAtom: null,
                    isActive: false,
                    position: null
                },
                atomEditing: {
                    selectedAtom: null,
                    isMoving: false,
                    originalPosition: null,
                    movePreview: null
                }
            };
            
            // UI Elements
            const menuBtn = document.getElementById('menuBtn');
            const closeSidebar = document.getElementById('closeSidebar');
            const sidebar = document.getElementById('sidebar');
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const closeHelpModal = document.getElementById('closeHelpModal');
            const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
            const statusDisplay = document.getElementById('status');
            const measurementDisplay = document.getElementById('measurement');
            const distanceValue = document.getElementById('distanceValue');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const atomCount = document.getElementById('atomCount');
            const bondCount = document.getElementById('bondCount');
            const floatingTooltip = document.getElementById('floatingTooltip');
            const contextMenu = document.getElementById('contextMenu');
            const atomContextMenu = document.getElementById('atomContextMenu');
            
            // Formula input elements
            const formulaInput = document.getElementById('formulaInput');
            const parseFormulaBtn = document.getElementById('parseFormulaBtn');
            
            // View toggle elements
            const toggleViewBtn = document.getElementById('toggleViewBtn');
            const toggleLabelsBtn = document.getElementById('toggleLabelsBtn');
            const view3D = document.getElementById('view3D');
            const view2D = document.getElementById('view2D');
            const canvas2D = document.getElementById('canvas2D');
            const gridToggleBtn = document.getElementById('gridToggleBtn');
            const snapToggleBtn = document.getElementById('snapToggleBtn');
            
            // Initialize 2D canvas
            const ctx2D = canvas2D.getContext('2d');
            
            // Event listeners for 2D canvas
            canvas2D.addEventListener('mousedown', onCanvas2DMouseDown);
            canvas2D.addEventListener('mousemove', onCanvas2DMouseMove);
            canvas2D.addEventListener('mouseup', onCanvas2DMouseUp);
            canvas2D.addEventListener('wheel', onCanvas2DWheel);
            
            // Resize canvas to match display size
            function resizeCanvas() {
                const rect = canvas2D.getBoundingClientRect();
                canvas2D.width = rect.width;
                canvas2D.height = rect.height;
                
                // Centralizar a visualização
                state.view2D.offsetX = canvas2D.width / 2;
                state.view2D.offsetY = canvas2D.height / 2;
                
                // Redesenhar o canvas
                if (state.viewMode === '2D') {
                    draw2D();
                }
            }
            
            // Tool buttons
            const toolButtons = {
                select: document.getElementById('selectTool'),
                atom: document.getElementById('atomTool'),
                move: document.getElementById('moveTool'),
                bond: document.getElementById('bondTool'),
                erase: document.getElementById('eraseTool'),
                rotate: document.getElementById('rotateTool'),
                measure: document.getElementById('measureTool')
            };
            
            // Atom buttons
            const atomButtons = document.querySelectorAll('.atom-btn');
            
            // Bond buttons
            const bondButtons = document.querySelectorAll('.bond-btn');
            
            // Action buttons
            const optimizeBtn = document.getElementById('optimizeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const addHydrogensBtn = document.getElementById('addHydrogensBtn');
            
            // View controls
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetViewBtn = document.getElementById('resetViewBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            // Molecule preset buttons
            const molButtons = document.querySelectorAll('.mol-btn');
            
            // Export buttons
            const exportPNGBtn = document.getElementById('exportPNGBtn');
            const exportOBJBtn = document.getElementById('exportOBJBtn');
            
            // Tooltip elements
            const tooltipElements = document.querySelectorAll('.tooltip');
            
            // Three.js scene setup
            const container = document.getElementById('renderCanvas');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add subtle blue rim light for better depth perception
            const rimLight = new THREE.DirectionalLight(0x3b82f6, 0.3);
            rimLight.position.set(-1, -1, -1);
            scene.add(rimLight);
            
            // Molecular data
            const molecules = {
                atoms: [],
                bonds: []
            };
            
            // Atom geometry and material
            const atomGeometry = new THREE.SphereGeometry(0.5, 32, 32); // Aumentado de 0.4 para 0.5
            const hydrogenGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Geometria menor para hidrogênio
            const atomMaterials = {
                'H': new THREE.MeshPhongMaterial({ color: 0x3498DB }),
                'C': new THREE.MeshPhongMaterial({ color: 0x555555 }),
                'O': new THREE.MeshPhongMaterial({ color: 0xFF5733 }),
                'N': new THREE.MeshPhongMaterial({ color: 0x2980B9 }),
                'S': new THREE.MeshPhongMaterial({ color: 0xffff30 }),
                'P': new THREE.MeshPhongMaterial({ color: 0xff8000 }),
                'F': new THREE.MeshPhongMaterial({ color: 0x1ff01f }),
                'Cl': new THREE.MeshPhongMaterial({ color: 0x1D8348 }),
                'Br': new THREE.MeshPhongMaterial({ color: 0x1ff01f }),
                'I': new THREE.MeshPhongMaterial({ color: 0x1ff01f })
            };
            
            // Bond geometry and material
            const bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const bondMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            // Raycaster for interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Initialize tooltips
            tooltipElements.forEach(el => {
                const tooltipText = el.getAttribute('data-tooltip');
                
                el.addEventListener('mouseenter', (e) => {
                    floatingTooltip.textContent = tooltipText;
                    floatingTooltip.style.left = `${e.clientX}px`;
                    floatingTooltip.style.top = `${e.clientY}px`;
                    floatingTooltip.style.opacity = '1';
                });
                
                el.addEventListener('mouseleave', () => {
                    floatingTooltip.style.opacity = '0';
                });
                
                el.addEventListener('mousemove', (e) => {
                    floatingTooltip.style.left = `${e.clientX}px`;
                    floatingTooltip.style.top = `${e.clientY}px`;
                });
            });
            
            // Event listeners for UI
            menuBtn.addEventListener('click', () => {
                sidebar.classList.add('open');
            });
            
            closeSidebar.addEventListener('click', () => {
                sidebar.classList.remove('open');
            });
            
            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            
            closeHelpModal.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });
            
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });
            
            // Fechar modal ao clicar fora
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.add('hidden');
                }
            });
            
            // Fechar sidebar ao clicar fora (mobile)
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768) { // Apenas no mobile
                    const sidebar = document.getElementById('sidebar');
                    const menuBtn = document.getElementById('menuBtn');
                    
                    // Se a sidebar está aberta e o clique não foi na sidebar nem no botão do menu
                    if (sidebar.classList.contains('open') && 
                        !sidebar.contains(e.target) && 
                        !menuBtn.contains(e.target)) {
                        sidebar.classList.remove('open');
                    }
                }
            });
            
            // Fechar sidebar ao clicar no canvas/área de trabalho (mobile)
            const renderCanvas = document.getElementById('renderCanvas');
            const canvas2DElement = document.getElementById('canvas2D');
            
            if (renderCanvas) {
                renderCanvas.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) { // Apenas no mobile
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar.classList.contains('open')) {
                            sidebar.classList.remove('open');
                        }
                    }
                });
            }
            
            if (canvas2DElement) {
                canvas2DElement.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) { // Apenas no mobile
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar.classList.contains('open')) {
                            sidebar.classList.remove('open');
                        }
                    }
                });
            }
            
            // Context Menu Event Listeners
            let contextMenuVisible = false;
            
            // Show context menu on right click
            function showContextMenu(event) {
                event.preventDefault();
                
                // Hide context menu if already visible
                if (contextMenuVisible) {
                    hideContextMenu();
                    return;
                }
                
                // Get the canvas container (main content area)
                const mainContent = document.getElementById('main-content');
                const mainContentRect = mainContent.getBoundingClientRect();
                
                // Calculate position relative to the main content area
                // Add small offset so menu doesn't appear exactly under cursor
                const x = event.clientX - mainContentRect.left;
                const y = event.clientY - mainContentRect.top - 70; // Position  above cursor
                
                // Temporarily show menu to get its actual dimensions
                contextMenu.classList.remove('hidden');
                const contextMenuRect = contextMenu.getBoundingClientRect();
                const menuWidth = contextMenuRect.width;
                const menuHeight = contextMenuRect.height;
                contextMenu.classList.add('hidden');
                
                // Adjust position if menu would go off-screen
                let finalX = x;
                let finalY = y;
                
                // Check right edge
                if (x + menuWidth > mainContentRect.width) {
                    finalX = x - menuWidth - 10; // Add extra margin
                }
                
                // Check bottom edge
                if (y + menuHeight > mainContentRect.height) {
                    finalY = y - menuHeight - 10; // Add extra margin
                }
                
                // Ensure menu doesn't go off the left or top edges
                finalX = Math.max(10, finalX); // Add margin from edges
                finalY = Math.max(10, finalY); // Add margin from edges
                
                // Position the context menu
                contextMenu.style.left = `${finalX}px`;
                contextMenu.style.top = `${finalY}px`;
                
                // Show the context menu
                contextMenu.classList.remove('hidden');
                contextMenuVisible = true;
                
                // Update active state of current tool in context menu
                updateContextMenuActiveState();
            }
            
            // Hide context menu
            function hideContextMenu() {
                contextMenu.classList.add('hidden');
                contextMenuVisible = false;
            }
            
            // Update active state in context menu
            function updateContextMenuActiveState() {
                const contextMenuItems = contextMenu.querySelectorAll('.context-menu-item[data-tool]');
                contextMenuItems.forEach(item => {
                    const tool = item.getAttribute('data-tool');
                    if (tool === state.currentTool) {
                        item.classList.add('bg-blue-100', 'text-blue-700');
                        item.classList.remove('hover:bg-blue-50');
                    } else {
                        item.classList.remove('bg-blue-100', 'text-blue-700');
                        item.classList.add('hover:bg-blue-50');
                    }
                });
            }
            
            // Add right click event listeners to both canvases
            if (renderCanvas) {
                // Note: renderCanvas contextmenu is handled by the 3D canvas inside it
            }
            
            if (canvas2DElement) {
                canvas2DElement.addEventListener('contextmenu', showContextMenu);
            }
            
            // Hide context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (contextMenuVisible && !contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            
            // Hide context menu on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && contextMenuVisible) {
                    hideContextMenu();
                }
                if (e.key === 'Escape' && state.atomEditing.isMoving) {
                    // Cancel atom movement and restore original position
                    if (state.atomEditing.selectedAtom !== null && state.atomEditing.originalPosition) {
                        const atom = molecules.atoms[state.atomEditing.selectedAtom];
                        if (atom) {
                            atom.position.copy(state.atomEditing.originalPosition);
                            if (atom.mesh) {
                                atom.mesh.position.copy(state.atomEditing.originalPosition);
                            }
                            if (atom.sprite) {
                                atom.sprite.position.copy(state.atomEditing.originalPosition);
                            }
                        }
                    }
                    stopMovingAtom();
                }
            });
            
            // Context menu item click handlers
            contextMenu.addEventListener('click', (e) => {
                const item = e.target.closest('.context-menu-item');
                if (!item) return;
                
                const tool = item.getAttribute('data-tool');
                const action = item.getAttribute('data-action');
                
                if (tool) {
                    // Switch to the selected tool
                    setActiveTool(tool);
                    hideContextMenu();
                } else if (action) {
                    // Execute the selected action
                    switch (action) {
                        case 'optimize':
                            optimizeGeometry();
                            break;
                        case 'addHydrogens':
                            addHydrogens();
                            break;
                        case 'clear':
                            clearMolecule();
                            break;
                    }
                    hideContextMenu();
                }
            });
            
            // Atom Context Menu Event Listeners
            let atomContextMenuVisible = false;
            let selectedAtomForContext = null;
            
            // Show atom context menu on right click over atom
            function onCanvas3DContextMenu(event) {
                event.preventDefault();
                
                // Hide any existing context menus
                if (contextMenuVisible) {
                    hideContextMenu();
                }
                if (atomContextMenuVisible) {
                    hideAtomContextMenu();
                    return;
                }
                
                // Get mouse position and check for atom intersection
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    // Skip preview objects - but still show regular context menu
                    if (object.userData.isPreview || object.userData.isMovePreview) {
                        showContextMenu(event);
                        return;
                    }
                    
                    // Check if it's an atom
                    let atomIndex = null;
                    if (object.userData.atomIndex !== undefined) {
                        atomIndex = object.userData.atomIndex;
                    } else if (object.parent && object.parent.userData && object.parent.userData.atomIndex !== undefined) {
                        atomIndex = object.parent.userData.atomIndex;
                    }
                    
                    if (atomIndex !== null) {
                        selectedAtomForContext = atomIndex;
                        showAtomContextMenu(event);
                        return;
                    }
                }
                
                // If no atom was clicked, show regular context menu
                showContextMenu(event);
            }
            
            // Show atom context menu
            function showAtomContextMenu(event) {
                // Get the canvas container (main content area)
                const mainContent = document.getElementById('main-content');
                const mainContentRect = mainContent.getBoundingClientRect();
                
                // Calculate position relative to the main content area
                const x = event.clientX - mainContentRect.left;
                const y = event.clientY - mainContentRect.top - 70; // Position above cursor
                
                // Temporarily show menu to get its actual dimensions
                atomContextMenu.classList.remove('hidden');
                const atomContextMenuRect = atomContextMenu.getBoundingClientRect();
                const menuWidth = atomContextMenuRect.width;
                const menuHeight = atomContextMenuRect.height;
                atomContextMenu.classList.add('hidden');
                
                // Adjust position if menu would go off-screen
                let finalX = x;
                let finalY = y;
                
                // Check right edge
                if (x + menuWidth > mainContentRect.width) {
                    finalX = x - menuWidth - 10;
                }
                
                // Check bottom edge
                if (y + menuHeight > mainContentRect.height) {
                    finalY = y - menuHeight - 10;
                }
                
                // Ensure menu doesn't go off the left or top edges
                finalX = Math.max(10, finalX);
                finalY = Math.max(10, finalY);
                
                // Position the atom context menu
                atomContextMenu.style.left = `${finalX}px`;
                atomContextMenu.style.top = `${finalY}px`;
                
                // Show the atom context menu
                atomContextMenu.classList.remove('hidden');
                atomContextMenuVisible = true;
            }
            
            // Hide atom context menu
            function hideAtomContextMenu() {
                atomContextMenu.classList.add('hidden');
                atomContextMenuVisible = false;
                selectedAtomForContext = null;
            }
            
            // Hide atom context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (atomContextMenuVisible && !atomContextMenu.contains(e.target)) {
                    hideAtomContextMenu();
                }
            });
            
            // Hide atom context menu on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && atomContextMenuVisible) {
                    hideAtomContextMenu();
                }
            });
            
            // Atom context menu click handler
            atomContextMenu.addEventListener('click', (e) => {
                const item = e.target.closest('.atom-context-menu-item');
                if (!item || selectedAtomForContext === null) return;
                
                const action = item.getAttribute('data-atom-action');
                
                switch (action) {
                    case 'select':
                        // Select the atom
                        state.selectedAtoms = [selectedAtomForContext];
                        updateAtomSelection();
                        break;
                    case 'move':
                        // Switch to move tool and select the atom
                        setActiveTool('move');
                        state.selectedAtoms = [selectedAtomForContext];
                        updateAtomSelection();
                        break;
                    case 'changeElement':
                        // Open element selection for this atom
                        changeAtomElement(selectedAtomForContext);
                        break;
                    case 'addBond':
                        // Switch to bond tool and select the atom
                        setActiveTool('bond');
                        state.selectedAtoms = [selectedAtomForContext];
                        updateAtomSelection();
                        break;
                    case 'delete':
                        // Delete only the atom
                        deleteAtom(selectedAtomForContext, false);
                        break;
                    case 'deleteWithBonds':
                        // Delete the atom and all its bonds
                        deleteAtom(selectedAtomForContext, true);
                        break;
                }
                
                hideAtomContextMenu();
            });
            
            // Tool selection
            Object.keys(toolButtons).forEach(tool => {
                toolButtons[tool].addEventListener('click', () => {
                    setActiveTool(tool);
                });
            });
            
            function setActiveTool(tool) {
                state.currentTool = tool;
                
                // Update UI
                Object.values(toolButtons).forEach(btn => {
                    btn.classList.remove('active');
                });
                toolButtons[tool].classList.add('active');
                
                // Update status
                const toolNames = {
                    select: 'Seleção',
                    atom: 'Adicionar',
                    move: 'Mover',
                    bond: 'Adicionar',
                    erase: 'Apagar',
                    rotate: 'Rotacionar',
                    measure: 'Medir'
                };
                
                const toolIcons = {
                    select: 'fa-mouse-pointer',
                    move: 'fa-arrows-alt',
                    erase: 'fa-eraser',
                    measure: 'fa-ruler'
                };
                
                statusDisplay.innerHTML = `<i class="fas ${toolIcons[tool]} mr-1"></i> ${toolNames[tool]} `;
                
                // Configurar controles com base na ferramenta selecionada
                if (tool === 'rotate') {
                    // Ativar controles de câmera para rotação
                    controls.enabled = true;
                    controls.enableRotate = true;
                    controls.enablePan = true;
                    controls.enableZoom = true;
                } else if (tool === 'select' || tool === 'move') {
                    // Permitir apenas rotação no modo de seleção e movimento
                    controls.enabled = true;
                    controls.enableRotate = true;
                    controls.enablePan = false;
                    controls.enableZoom = true;
                } else {
                    // Desativar controles de câmera para outras ferramentas
                    controls.enabled = false;
                }
                
                // Reset measurement if not in measure mode
                if (tool !== 'measure') {
                    state.measurement.active = false;
                    state.measurement.points = [];
                    measurementDisplay.classList.add('hidden');
                }
                
                // Update context menu active state
                if (contextMenuVisible) {
                    updateContextMenuActiveState();
                }
                
                // Hide atom preview when switching tools
                if (tool !== 'atom') {
                    hideAtomPreview();
                }
                
                // Stop atom editing when switching tools
                if (tool !== 'move') {
                    stopMovingAtom();
                }
            }
            
            // Atom selection
            atomButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentAtom = btn.dataset.atom;
                    
                    // Update UI
                    atomButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                                    // Show tooltip
                floatingTooltip.textContent = `Selecionado: ${btn.dataset.atom}`;
                    const rect = btn.getBoundingClientRect();
                    floatingTooltip.style.left = `${rect.left + rect.width/2}px`;
                    floatingTooltip.style.top = `${rect.top - 10}px`;
                    floatingTooltip.style.opacity = '1';
                    
                    setTimeout(() => {
                        floatingTooltip.style.opacity = '0';
                    }, 1000);
                });
            });
            
            // Bond selection
            bondButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentBond = parseInt(btn.dataset.bond);
                    
                    // Update UI
                    bondButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            
            // Molecule presets
            molButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const molType = btn.dataset.mol;
                    loadMoleculePreset(molType);
                });
            });
            
            function loadMoleculePreset(type) {
                clearMolecule();
                
                switch(type) {
                    case 'h2o':
                        // Água (H2O)
                        addAtom('O', 0, 0, 0);
                        addAtom('H', 0.76, 0.5, 0);
                        addAtom('H', -0.76, 0.5, 0);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        break;
                    case 'co2':
                        // Dióxido de Carbono (CO2)
                        addAtom('C', 0, 0, 0);
                        addAtom('O', -1.16, 0, 0);
                        addAtom('O', 1.16, 0, 0);
                        addBond(0, 1, 2);
                        addBond(0, 2, 2);
                        break;
                    case 'ch4':
                        // Metano (CH4)
                        addAtom('C', 0, 0, 0);
                        addAtom('H', -0.63, -0.63, -0.63);
                        addAtom('H', 0.63, -0.63, 0.63);
                        addAtom('H', -0.63, 0.63, 0.63);
                        addAtom('H', 0.63, 0.63, -0.63);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        addBond(0, 4, 1);
                        break;
                    case 'nh3':
                        // Amoníaco (NH3)
                        addAtom('N', 0, 0, 0);
                        addAtom('H', -0.94, -0.33, 0);
                        addAtom('H', 0.47, -0.33, -0.81);
                        addAtom('H', 0.47, -0.33, 0.81);
                        addBond(0, 1, 1);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        break;
                    case 'c2h4':
                        // Etileno (C2H4)
                        addAtom('C', -0.67, 0, 0);
                        addAtom('C', 0.67, 0, 0);
                        addAtom('H', -1.24, -0.93, 0);
                        addAtom('H', -1.24, 0.93, 0);
                        addAtom('H', 1.24, -0.93, 0);
                        addAtom('H', 1.24, 0.93, 0);
                        addBond(0, 1, 2);
                        addBond(0, 2, 1);
                        addBond(0, 3, 1);
                        addBond(1, 4, 1);
                        addBond(1, 5, 1);
                        break;
                    case 'c2h2':
                        // Acetileno (C2H2)
                        addAtom('C', -0.6, 0, 0);
                        addAtom('C', 0.6, 0, 0);
                        addAtom('H', -1.66, 0, 0);
                        addAtom('H', 1.66, 0, 0);
                        addBond(0, 1, 3);
                        addBond(0, 2, 1);
                        addBond(1, 3, 1);
                        break;
                    case 'o2':
                        // Oxigênio (O2)
                        addAtom('O', -0.6, 0, 0);
                        addAtom('O', 0.6, 0, 0);
                        addBond(0, 1, 2);
                        break;
                    case 'n2':
                        // Nitrogênio (N2)
                        addAtom('N', -0.55, 0, 0);
                        addAtom('N', 0.55, 0, 0);
                        addBond(0, 1, 3);
                        break;
                    case 'hcl':
                        // Ácido Clorídrico (HCl)
                        addAtom('H', -0.6, 0, 0);
                        addAtom('Cl', 0.6, 0, 0);
                        addBond(0, 1, 1);
                        break;
                }
                
                optimizeGeometry();
                updateCounts();
                
                // Se estiver no modo 2D, converter e redesenhar
                if (state.viewMode === '2D') {
                    convert3Dto2D();
                    draw2D();
                }
            }
            
            // Molecule actions
            optimizeBtn.addEventListener('click', optimizeGeometry);
            clearBtn.addEventListener('click', clearMolecule);
            addHydrogensBtn.addEventListener('click', addHydrogens);
            
            // View controls
            zoomInBtn.addEventListener('click', () => {
                camera.position.z -= 0.5;
            });
            
            zoomOutBtn.addEventListener('click', () => {
                camera.position.z += 0.5;
            });
            
            resetViewBtn.addEventListener('click', () => {
                camera.position.set(0, 0, 5);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Export
            exportPNGBtn.addEventListener('click', exportPNG);
            exportOBJBtn.addEventListener('click', exportOBJ);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        setActiveTool('atom');
                        break;
                    case 'b':
                        setActiveTool('bond');
                        break;
                    case 'e':
                        setActiveTool('erase');
                        break;
                    case 'r':
                        setActiveTool('rotate');
                        break;
                    case 'm':
                        setActiveTool('move');
                        break;
                    case 'd':
                        setActiveTool('measure');
                        break;
                    case 's':
                        setActiveTool('select');
                        break;
                }
            });
            
            // Mouse/touch events
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('contextmenu', onCanvas3DContextMenu, false);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Toggle view mode between 2D and 3D
            toggleViewBtn.addEventListener('click', toggleViewMode);
            
            // Toggle labels visibility
            toggleLabelsBtn.addEventListener('click', toggleLabelsVisibility);
            
            function toggleViewMode() {
                // Hide atom preview when switching views
                hideAtomPreview();
                
                if (state.viewMode === '3D') {
                    // Mudar para visualização 2D
                    state.viewMode = '2D';
                    view3D.classList.add('hidden');
                    view2D.classList.remove('hidden');
                    
                    // Inicializar o canvas 2D se for a primeira vez
                    resizeCanvas();
                    
                    // Converter moléculas 3D para 2D
                    convert3Dto2D();
                    
                    // Desenhar a visualização 2D
                    draw2D();
                    
                    // Atualizar o botão
                    toggleViewBtn.innerHTML = '<i class="fas fa-cube mr-1"></i> <span class="text-sm">3D</span>';
                } else {
                    // Mudar para visualização 3D
                    state.viewMode = '3D';
                    view2D.classList.add('hidden');
                    view3D.classList.remove('hidden');
                    
                    // Converter moléculas 2D para 3D
                    convert2Dto3D();
                    
                    // Atualizar o botão
                    toggleViewBtn.innerHTML = '<i class="fas fa-square mr-1"></i> <span class="text-sm">2D</span>';
                }
            }
            
            function toggleLabelsVisibility() {
                // Alternar estado de visibilidade
                state.labelsVisible = !state.labelsVisible;
                
                // Atualizar visibilidade de todas as legendas
                molecules.atoms.forEach(atom => {
                    if (atom.sprite) {
                        atom.sprite.visible = state.labelsVisible;
                    }
                });
                
                // Atualizar aparência do botão
                if (state.labelsVisible) {
                    toggleLabelsBtn.classList.remove('bg-gray-500');
                    toggleLabelsBtn.classList.add('bg-green-500');
                    toggleLabelsBtn.innerHTML = '<i class="fas fa-tags mr-1"></i> <span class="text-sm">Legendas</span>';
                } else {
                    toggleLabelsBtn.classList.remove('bg-green-500');
                    toggleLabelsBtn.classList.add('bg-gray-500');
                    toggleLabelsBtn.innerHTML = '<i class="fas fa-eye-slash mr-1"></i> <span class="text-sm">Legendas</span>';
                }
            }
            
            // Grid and snap toggle
            gridToggleBtn.addEventListener('click', () => {
                state.view2D.gridEnabled = !state.view2D.gridEnabled;
                gridToggleBtn.classList.toggle('bg-blue-500');
                gridToggleBtn.classList.toggle('text-white');
                draw2D();
            });
            
            snapToggleBtn.addEventListener('click', () => {
                state.view2D.snapEnabled = !state.view2D.snapEnabled;
                snapToggleBtn.classList.toggle('bg-blue-500');
                snapToggleBtn.classList.toggle('text-white');
            });
            
            // Functions for molecule manipulation
            
            // Start moving atom
            function startMovingAtom() {
                if (state.atomEditing.selectedAtom === null) return;
                
                const atom = molecules.atoms[state.atomEditing.selectedAtom];
                if (!atom) return;
                
                // Store original position
                state.atomEditing.originalPosition = atom.position.clone();
                state.atomEditing.isMoving = true;
                
                // Highlight the atom being moved
                if (atom.mesh) {
                    atom.mesh.material.emissive.setHex(0x00ff00); // Green highlight
                }
                
                // Update status
                statusDisplay.innerHTML = '<i class="fas fa-arrows-alt mr-1"></i> Movendo Átomo - Clique para posicionar';
            }
            
            // Stop moving atom
            function stopMovingAtom() {
                if (state.atomEditing.selectedAtom === null) return;
                
                const atom = molecules.atoms[state.atomEditing.selectedAtom];
                if (atom && atom.mesh) {
                    // Remove highlight
                    atom.mesh.material.emissive.setHex(0x000000);
                }
                
                // Update all bonds connected to this atom
                molecules.bonds.forEach(bond => {
                    if (bond.atom1 === state.atomEditing.selectedAtom || bond.atom2 === state.atomEditing.selectedAtom) {
                        updateBondVisual(bond);
                    }
                });
                
                // Remove move preview
                if (state.atomEditing.movePreview) {
                    scene.remove(state.atomEditing.movePreview);
                    state.atomEditing.movePreview = null;
                }
                
                // Reset state
                state.atomEditing.isMoving = false;
                state.atomEditing.selectedAtom = null;
                state.atomEditing.originalPosition = null;
                
                // Update status
                statusDisplay.innerHTML = '<i class="fas fa-mouse-pointer mr-1"></i> Modo Seleção';
            }
            
            // Move atom to new position
            function moveAtomToPosition(position) {
                if (state.atomEditing.selectedAtom === null || !state.atomEditing.isMoving) return;
                
                const atom = molecules.atoms[state.atomEditing.selectedAtom];
                if (!atom) return;
                
                // Update atom position
                atom.position.copy(position);
                
                // Update mesh position
                if (atom.mesh) {
                    atom.mesh.position.copy(position);
                }
                
                // Update sprite position (sempre centralizado)
                if (atom.sprite) {
                    atom.sprite.position.copy(position);
                }
                
                // Show move preview
                showMovePreview(position);
            }
            
            // Show move preview
            function showMovePreview(position) {
                // Remove existing preview
                if (state.atomEditing.movePreview) {
                    scene.remove(state.atomEditing.movePreview);
                }
                
                // Create preview sphere
                // Usar geometria menor para hidrogênio no preview de movimento
                const previewGeometry = atom.element === 'H' ? 
                    new THREE.SphereGeometry(0.3, 16, 16) : 
                    new THREE.SphereGeometry(0.5, 16, 16);
                const previewMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                
                const previewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
                previewMesh.position.copy(position);
                previewMesh.userData = { isMovePreview: true };
                
                scene.add(previewMesh);
                state.atomEditing.movePreview = previewMesh;
            }
            
            // Show atom placement preview
            function showAtomPreview(position, targetAtom = null) {
                // Remove existing preview
                hideAtomPreview();
                
                // Create preview atom
                const material = atomMaterials[state.currentAtom] || atomMaterials['C'];
                // Usar geometria menor para hidrogênio no preview
                const previewGeometry = state.currentAtom === 'H' ? 
                    new THREE.SphereGeometry(0.3, 16, 16) : 
                    new THREE.SphereGeometry(0.5, 16, 16);
                const previewMaterial = new THREE.MeshPhongMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.7,
                    wireframe: false
                });
                
                const previewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
                previewMesh.position.copy(position);
                previewMesh.userData = { isPreview: true };
                
                // Add pulsing animation
                const pulseScale = 1.0;
                const pulseSpeed = 0.05;
                let pulseDirection = 1;
                
                function animatePreview() {
                    if (previewMesh.userData.isPreview) {
                        pulseScale += pulseDirection * pulseSpeed;
                        if (pulseScale >= 1.2) {
                            pulseDirection = -1;
                        } else if (pulseScale <= 0.8) {
                            pulseDirection = 1;
                        }
                        previewMesh.scale.setScalar(pulseScale);
                        requestAnimationFrame(animatePreview);
                    }
                }
                
                scene.add(previewMesh);
                state.atomPreview.mesh = previewMesh;
                state.atomPreview.position = position.clone();
                state.atomPreview.isActive = true;
                animatePreview();
                
                // Show bond preview if there's a target atom
                if (targetAtom) {
                    showBondPreview(position, targetAtom.position);
                    state.atomPreview.targetAtom = targetAtom;
                }
            }
            
            // Show bond preview between two positions
            function showBondPreview(pos1, pos2) {
                // Remove existing bond preview
                hideBondPreview();
                
                // Create bond preview
                const bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
                const bondMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.6
                });
                
                // Calculate position and rotation for the bond
                const center = new THREE.Vector3();
                center.addVectors(pos1, pos2);
                center.multiplyScalar(0.5);
                
                const direction = new THREE.Vector3().subVectors(pos2, pos1);
                const length = direction.length();
                const adjustedLength = length - 0.6; // Subtract both atom radii (reduzido para aumentar o comprimento da haste)
                
                const bondGroup = new THREE.Group();
                bondGroup.position.copy(center);
                
                // Orient the bond
                bondGroup.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction.clone().normalize()
                );
                
                const cylinder = new THREE.Mesh(bondGeometry, bondMaterial);
                cylinder.scale.y = adjustedLength;
                bondGroup.add(cylinder);
                
                bondGroup.userData = { isPreview: true };
                scene.add(bondGroup);
                state.atomPreview.bondPreview = bondGroup;
            }
            
            // Hide atom preview
            function hideAtomPreview() {
                if (state.atomPreview.mesh) {
                    state.atomPreview.mesh.userData.isPreview = false;
                    scene.remove(state.atomPreview.mesh);
                    state.atomPreview.mesh = null;
                }
                hideBondPreview();
                state.atomPreview.targetAtom = null;
                state.atomPreview.position = null;
                state.atomPreview.isActive = false;
            }
            
            // Hide bond preview
            function hideBondPreview() {
                if (state.atomPreview.bondPreview) {
                    scene.remove(state.atomPreview.bondPreview);
                    state.atomPreview.bondPreview = null;
                }
            }
            
            // Find nearby atom for potential bonding
            function findNearbyAtomForBonding(position, maxDistance = 2.0) {
                let closestAtom = null;
                let closestDistance = Infinity;
                
                molecules.atoms.forEach(atom => {
                    const distance = atom.position.distanceTo(position);
                    if (distance < maxDistance && distance < closestDistance) {
                        closestDistance = distance;
                        closestAtom = atom;
                    }
                });
                
                return closestAtom;
            }
            
            function calculateOptimalAtomPosition() {
                const offsetMouse = {
                    x: mouse.x - (510 / window.innerWidth) * 2, //
                    y: mouse.y - (-150 / window.innerWidth) * 2,
                };
                
                // Create a ray from the camera through the offset mouse position
                const tempRaycaster = new THREE.Raycaster();
                tempRaycaster.setFromCamera(offsetMouse, camera);
                
                // Create a plane at the center of the scene, perpendicular to camera direction
                const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const planeDistance = 0; // Plane at the center (0,0,0)
                const plane = new THREE.Plane(cameraDirection, planeDistance);
                
                // Calculate intersection with the plane
                const intersection = new THREE.Vector3();
                if (tempRaycaster.ray.intersectPlane(plane, intersection)) {
                    return intersection;
                }
                
                // Fallback: point at fixed distance in ray direction
                const fallbackPosition = new THREE.Vector3();
                tempRaycaster.ray.at(5, fallbackPosition);
                return fallbackPosition;
            }
            
            // Função para atualizar todas as legendas existentes
            function updateAllAtomLabels() {
                molecules.atoms.forEach(atom => {
                    if (atom.sprite) {
                        // Sempre centralizar a legenda no átomo
                        atom.sprite.position.copy(atom.position);
                    }
                });
            }

            // Função para recriar todas as legendas com o novo sistema
            function recreateAllAtomLabels() {
                molecules.atoms.forEach(atom => {
                    if (atom.sprite) {
                        // Remover sprite antigo
                        scene.remove(atom.sprite);
                        
                        // Criar nova legenda centralizada
                        const atomRadius = atom.element === 'H' ? 0.3 : 0.5;
                        const newSprite = createCenteredLabel(atom.element, atom.position, atomRadius);
                        scene.add(newSprite);
                        
                        // Atualizar referência
                        atom.sprite = newSprite;
                    }
                });
            }

            // Função para detectar estruturas moleculares conhecidas
            function detectKnownMolecule() {
                if (molecules.atoms.length === 0) return null;
                
                // Obter fórmula molecular
                const formula = getMolecularFormula();
                
                // Lista de estruturas conhecidas
                const knownMolecules = {
                    'H2O': { name: 'Água', description: 'Molécula polar essencial para a vida', geometry: 'bent' },
                    'CO2': { name: 'Dióxido de Carbono', description: 'Gás responsável pelo efeito estufa', geometry: 'linear' },
                    'CH4': { name: 'Metano', description: 'Hidrocarboneto mais simples, gás natural', geometry: 'tetrahedral' },
                    'NH3': { name: 'Amoníaco', description: 'Base fraca, usado em fertilizantes', geometry: 'trigonal_pyramidal' },
                    'C2H4': { name: 'Etileno', description: 'Alqueno usado na produção de plásticos', geometry: 'trigonal_planar' },
                    'C2H2': { name: 'Acetileno', description: 'Alquino usado em soldas', geometry: 'linear' },
                    'O2': { name: 'Oxigênio', description: 'Gás essencial para respiração', geometry: 'linear' },
                    'N2': { name: 'Nitrogênio', description: 'Gás inerte, 78% da atmosfera', geometry: 'linear' },
                    'HCl': { name: 'Ácido Clorídrico', description: 'Ácido forte, usado na indústria', geometry: 'linear' },
                    'C6H6': { name: 'Benzeno', description: 'Hidrocarboneto aromático', geometry: 'aromatic' },
                    'C2H6': { name: 'Etano', description: 'Hidrocarboneto saturado', geometry: 'tetrahedral' },
                    'C3H8': { name: 'Propano', description: 'Gás usado como combustível', geometry: 'tetrahedral' },
                    'C4H10': { name: 'Butano', description: 'Gás usado em isqueiros', geometry: 'tetrahedral' },
                    'CH3OH': { name: 'Metanol', description: 'Álcool tóxico, usado como combustível', geometry: 'tetrahedral' },
                    'C2H5OH': { name: 'Etanol', description: 'Álcool usado em bebidas e combustível', geometry: 'tetrahedral' },
                    'H2S': { name: 'Sulfeto de Hidrogênio', description: 'Gás tóxico com cheiro de ovo podre', geometry: 'bent' },
                    'SO2': { name: 'Dióxido de Enxofre', description: 'Gás poluente, causa chuva ácida', geometry: 'bent' },
                    'HCN': { name: 'Cianeto de Hidrogênio', description: 'Gás extremamente tóxico', geometry: 'linear' },
                    'CH2O': { name: 'Formaldeído', description: 'Aldeído usado em conservantes', geometry: 'trigonal_planar' },
                    'C2H4O': { name: 'Acetaldeído', description: 'Aldeído presente no álcool', geometry: 'trigonal_planar' },
                    'C3H6': { name: 'Propeno', description: 'Alqueno usado em plásticos', geometry: 'trigonal_planar' },
                    'C4H8': { name: 'Buteno', description: 'Alqueno com múltiplos isômeros', geometry: 'trigonal_planar' },
                    'C5H12': { name: 'Pentano', description: 'Hidrocarboneto saturado', geometry: 'tetrahedral' },
                    'C6H14': { name: 'Hexano', description: 'Solvente orgânico', geometry: 'tetrahedral' },
                    'C2H6O': { name: 'Dimetil Éter', description: 'Éter usado como propelente', geometry: 'tetrahedral' }
                };
                
                return knownMolecules[formula] || null;
            }

            // Função para obter a fórmula molecular
            function getMolecularFormula() {
                const elementCounts = {};
                
                molecules.atoms.forEach(atom => {
                    elementCounts[atom.element] = (elementCounts[atom.element] || 0) + 1;
                });
                
                // Ordenar elementos (C, H, O, N, outros)
                const elementOrder = ['C', 'H', 'O', 'N', 'S', 'P', 'F', 'Cl', 'Br', 'I'];
                let formula = '';
                
                elementOrder.forEach(element => {
                    if (elementCounts[element]) {
                        formula += element;
                        if (elementCounts[element] > 1) {
                            formula += elementCounts[element];
                        }
                    }
                });
                
                // Adicionar outros elementos não listados
                Object.keys(elementCounts).forEach(element => {
                    if (!elementOrder.includes(element)) {
                        formula += element;
                        if (elementCounts[element] > 1) {
                            formula += elementCounts[element];
                        }
                    }
                });
                
                return formula;
            }

            // Função para mostrar alerta de estrutura conhecida
            function showMoleculeAlert(moleculeInfo) {
                // Remover alerta anterior se existir
                hideMoleculeAlert();
                
                // Criar elemento de alerta
                const alertDiv = document.createElement('div');
                alertDiv.id = 'moleculeAlert';
                alertDiv.className = 'fixed bottom-14 right-20 bg-green-500 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm animate-pulse';
                alertDiv.innerHTML = `
                    <div class="flex items-center mb-2">
                        <i class="fas fa-check-circle mr-2 text-xl"></i>
                        <h3 class="font-bold text-lg">Estrutura Detectada!</h3>
                    </div>
                    <div class="mb-2">
                        <p class="font-semibold text-lg">${moleculeInfo.name}</p>
                        <p class="text-sm opacity-90">${moleculeInfo.description}</p>
                    </div>
                    <button onclick="hideMoleculeAlert()" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm transition-colors">
                        Fechar
                    </button>
                `;
                
                document.body.appendChild(alertDiv);
                
                // Auto-remover após 5 segundos
                setTimeout(() => {
                    hideMoleculeAlert();
                }, 5000);
            }

            // Função para esconder alerta
            function hideMoleculeAlert() {
                const alertDiv = document.getElementById('moleculeAlert');
                if (alertDiv) {
                    alertDiv.remove();
                }
            }

            // Tornar função global para acesso pelo HTML
            window.hideMoleculeAlert = hideMoleculeAlert;

            // Função para criar legenda centralizada com efeitos visuais
            function createCenteredLabel(element, atomPosition, atomRadius) {
                // Criar canvas com fundo transparente e contraste
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                // Limpar canvas
                context.clearRect(0, 0, 128, 128);
                
                // Criar fundo circular com borda para contraste
                const centerX = 64;
                const centerY = 64;
                const radius = 50;
                
                // Fundo com gradiente radial para melhor visibilidade
                const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)'); // Centro branco
                gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.7)'); // Meio semi-transparente
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)'); // Borda transparente
                
                // Desenhar fundo circular
                context.fillStyle = gradient;
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                context.fill();
                
                // Adicionar borda escura para contraste
                context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                context.lineWidth = 4;
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                context.stroke();
                
                // Adicionar sombra ao texto para melhor legibilidade
                context.shadowColor = 'rgba(0, 0, 0, 0.8)';
                context.shadowBlur = 8;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                // Texto principal
                context.fillStyle = '#000000';
                context.font = 'bold 48px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(element, centerX, centerY);
                
                // Remover sombra e adicionar contorno branco
                context.shadowColor = 'transparent';
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 3;
                context.strokeText(element, centerX, centerY);
                
                // Criar sprite com propriedades especiais
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.95,
                    depthTest: false, // Sempre visível
                    depthWrite: false // Não afeta o buffer de profundidade
                });
                
                const sprite = new THREE.Sprite(spriteMaterial);
                
                // Posicionar no centro do átomo
                sprite.position.copy(atomPosition);
                
                // Escalar baseado no tamanho do átomo
                const scale = atomRadius * 1.2; // Ligeiramente maior que o átomo
                sprite.scale.set(scale, scale, scale);
                
                // Definir visibilidade baseada no estado atual
                sprite.visible = state.labelsVisible;
                
                return sprite;
            }

            // Função para calcular posição centralizada (sempre no centro do átomo)
            function calculateOptimalLabelPosition(atomPosition, element) {
                // Sempre retornar a posição central do átomo
                return atomPosition.clone();
            }

            function addAtom(element, x, y, z) {
                const atom = {
                    element: element,
                    position: new THREE.Vector3(x, y, z),
                    mesh: null
                };
                
                // Verificar se já existe um átomo muito próximo desta posição
                const minDistance = 0.5; // Distância mínima entre átomos
                const tooClose = molecules.atoms.some(existingAtom => {
                    const distance = existingAtom.position.distanceTo(atom.position);
                    return distance < minDistance;
                });
                
                // Se estiver muito próximo, ajustar a posição
                if (tooClose) {
                    // Adicionar pequeno deslocamento aleatório
                    x += (Math.random() - 0.5) * 0.5;
                    y += (Math.random() - 0.5) * 0.5;
                    z += (Math.random() - 0.5) * 0.5;
                    atom.position.set(x, y, z);
                }
                
                const material = atomMaterials[element] || atomMaterials['C'];
                // Usar geometria menor para átomos de hidrogênio
                const geometry = element === 'H' ? hydrogenGeometry : atomGeometry;
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                sphere.userData.atomIndex = molecules.atoms.length;
                scene.add(sphere);
                
                // Criar legenda centralizada com efeitos visuais
                const atomRadius = element === 'H' ? 0.3 : 0.5;
                const sprite = createCenteredLabel(element, atom.position, atomRadius);
                scene.add(sprite);
                
                atom.mesh = sphere;
                atom.sprite = sprite;
                molecules.atoms.push(atom);
                
                // Hide preview after adding atom
                hideAtomPreview();
                
                // Detectar estrutura molecular conhecida
                const detectedMolecule = detectKnownMolecule();
                if (detectedMolecule) {
                    showMoleculeAlert(detectedMolecule);
                }
                
                return molecules.atoms.length - 1;
            }
            
            function addBond(atom1Index, atom2Index, order = 1) {
                const atom1 = molecules.atoms[atom1Index];
                const atom2 = molecules.atoms[atom2Index];
                
                if (!atom1 || !atom2) return;
                
                // Check if bond already exists
                const existingBond = molecules.bonds.find(b => 
                    (b.atom1 === atom1Index && b.atom2 === atom2Index) || 
                    (b.atom1 === atom2Index && b.atom2 === atom1Index)
                );
                
                if (existingBond) {
                    // Update bond order if different
                    if (existingBond.order !== order) {
                        existingBond.order = order;
                        updateBondVisual(existingBond);
                    }
                    return;
                }
                
                const bond = {
                    atom1: atom1Index,
                    atom2: atom2Index,
                    order: order,
                    mesh: null
                };
                
                createBondVisual(bond);
                molecules.bonds.push(bond);
                
                // Detectar estrutura molecular conhecida
                const detectedMolecule = detectKnownMolecule();
                if (detectedMolecule) {
                    showMoleculeAlert(detectedMolecule);
                }
                
                return molecules.bonds.length - 1;
            }
            
            function createBondVisual(bond) {
                const atom1 = molecules.atoms[bond.atom1];
                const atom2 = molecules.atoms[bond.atom2];
                
                if (!atom1 || !atom2) return;
                
                // Calculate position and rotation for the bond cylinder
                const pos1 = atom1.position;
                const pos2 = atom2.position;
                
                const center = new THREE.Vector3();
                center.addVectors(pos1, pos2);
                center.multiplyScalar(0.5);
                
                const direction = new THREE.Vector3().subVectors(pos2, pos1);
                const length = direction.length();
                
                // Adjust length based on atom radii
                const adjustedLength = length - 0.6; // Subtract both atom radii (reduzido para aumentar o comprimento da haste)
                
                // Grupo para conter todas as partes da ligação
                const bondGroup = new THREE.Group();
                bondGroup.position.copy(center);
                
                // Orientação do grupo
                bondGroup.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction.clone().normalize()
                );
                
                // Para ligações simples, apenas um cilindro
                if (bond.order === 1) {
                    const cylinderGeometry = new THREE.CylinderGeometry(0.1, 0.1, adjustedLength, 8);
                    const cylinder = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    bondGroup.add(cylinder);
                }
                // Para ligações duplas, dois cilindros lado a lado
                else if (bond.order === 2) {
                    const offset = 0.12;
                    const cylinderGeometry = new THREE.CylinderGeometry(0.07, 0.07, adjustedLength, 8);
                    
                    const cylinder1 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder1.position.x = offset;
                    bondGroup.add(cylinder1);
                    
                    const cylinder2 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder2.position.x = -offset;
                    bondGroup.add(cylinder2);
                }
                // Para ligações triplas, três cilindros
                else if (bond.order === 3) {
                    const offset = 0.15;
                    const cylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, adjustedLength, 8);
                    
                    const cylinder1 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    bondGroup.add(cylinder1);
                    
                    const cylinder2 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder2.position.x = offset;
                    bondGroup.add(cylinder2);
                    
                    const cylinder3 = new THREE.Mesh(cylinderGeometry, bondMaterial);
                    cylinder3.position.x = -offset;
                    bondGroup.add(cylinder3);
                }
                
                scene.add(bondGroup);
                bond.mesh = bondGroup;
            }
            
            function updateBondVisual(bond) {
                if (bond.mesh) {
                    scene.remove(bond.mesh);
                }
                
                createBondVisual(bond);
            }
            
            function removeAtom(index) {
                if (index < 0 || index >= molecules.atoms.length) return;
                
                // Remove atom mesh
                const atom = molecules.atoms[index];
                if (atom.mesh) {
                    scene.remove(atom.mesh);
                }
                
                // Remove atom sprite label
                if (atom.sprite) {
                    scene.remove(atom.sprite);
                }
                
                // Remove all bonds connected to this atom
                // Iterar de trás para frente para evitar problemas de índice
                for (let i = molecules.bonds.length - 1; i >= 0; i--) {
                    const bond = molecules.bonds[i];
                    if (bond.atom1 === index || bond.atom2 === index) {
                        // Remove bond mesh from scene
                        if (bond.mesh) {
                            scene.remove(bond.mesh);
                        }
                        // Remove bond from array
                        molecules.bonds.splice(i, 1);
                    }
                }
                
                // Remove the atom from the array
                molecules.atoms.splice(index, 1);
                
                // Update indices in remaining atoms and bonds
                molecules.atoms.forEach((atom, i) => {
                    if (atom.mesh) {
                        atom.mesh.userData.atomIndex = i;
                    }
                });
                
                molecules.bonds.forEach(bond => {
                    if (bond.atom1 > index) bond.atom1--;
                    if (bond.atom2 > index) bond.atom2--;
                });
                
                // Update counts and redraw
                updateCounts();
                
                // Update all remaining bonds in 3D mode
                if (state.viewMode === '3D') {
                    molecules.bonds.forEach(bond => {
                        updateBondVisual(bond);
                    });
                } else {
                    // Redraw 2D mode
                    convert3Dto2D();
                    draw2D();
                }
            }
            
            function removeBond(index) {
                if (index < 0 || index >= molecules.bonds.length) return;
                
                const bond = molecules.bonds[index];
                if (bond.mesh) {
                    scene.remove(bond.mesh);
                }
                
                molecules.bonds.splice(index, 1);
                
                // Update counts and redraw
                updateCounts();
                
                // Update all remaining bonds in 3D mode
                if (state.viewMode === '3D') {
                    molecules.bonds.forEach(bond => {
                        updateBondVisual(bond);
                    });
                } else {
                    // Redraw 2D mode
                    convert3Dto2D();
                    draw2D();
                }
            }
            
            function clearMolecule() {
                // Remove all atoms and bonds
                molecules.atoms.forEach(atom => {
                    if (atom.mesh) {
                        scene.remove(atom.mesh);
                    }
                    if (atom.sprite) {
                        scene.remove(atom.sprite);
                    }
                });
                
                molecules.bonds.forEach(bond => {
                    if (bond.mesh) {
                        scene.remove(bond.mesh);
                    }
                });
                
                molecules.atoms = [];
                molecules.bonds = [];
                
                updateCounts();
            }
            
            // Function to update atom selection highlighting
            function updateAtomSelection() {
                // Clear previous selection
                state.selectedAtoms.forEach(index => {
                    const atom = molecules.atoms[index];
                    if (atom && atom.mesh) {
                        atom.mesh.material.emissive.setHex(0x000000);
                    }
                });
                
                // Highlight new selection
                state.selectedAtoms.forEach(index => {
                    const atom = molecules.atoms[index];
                    if (atom && atom.mesh) {
                        atom.mesh.material.emissive.setHex(0x333333);
                    }
                });
            }
            
            // Function to delete an atom
            function deleteAtom(atomIndex, deleteWithBonds = false) {
                if (atomIndex < 0 || atomIndex >= molecules.atoms.length) return;
                
                const atom = molecules.atoms[atomIndex];
                if (!atom) return;
                
                if (deleteWithBonds) {
                    // Use existing removeAtom function which removes bonds too
                    removeAtom(atomIndex);
                } else {
                    // Remove only the atom, keeping bonds (they will become dangling)
                    if (atom.mesh) {
                        scene.remove(atom.mesh);
                    }
                    if (atom.sprite) {
                        scene.remove(atom.sprite);
                    }
                    
                    // Remove the atom from the array
                    molecules.atoms.splice(atomIndex, 1);
                    
                    // Update indices in remaining atoms
                    molecules.atoms.forEach((atom, i) => {
                        if (atom.mesh) {
                            atom.mesh.userData.atomIndex = i;
                        }
                    });
                    
                    // Update bond indices (bonds pointing to higher indices need to be decremented)
                    molecules.bonds.forEach(bond => {
                        if (bond.atom1 > atomIndex) bond.atom1--;
                        if (bond.atom2 > atomIndex) bond.atom2--;
                    });
                    
                    // Update counts and redraw
                    updateCounts();
                    
                    // Update all remaining bonds in 3D mode
                    if (state.viewMode === '3D') {
                        molecules.bonds.forEach(bond => {
                            updateBondVisual(bond);
                        });
                    } else {
                        // Redraw 2D mode
                        convert3Dto2D();
                        draw2D();
                    }
                }
                
                // Clear selection if deleted atom was selected
                state.selectedAtoms = state.selectedAtoms.filter(idx => idx !== atomIndex);
                state.selectedAtoms = state.selectedAtoms.map(idx => idx > atomIndex ? idx - 1 : idx);
                
                updateCounts();
            }
            
            // Function to change atom element
            function changeAtomElement(atomIndex) {
                if (atomIndex < 0 || atomIndex >= molecules.atoms.length) return;
                
                const atom = molecules.atoms[atomIndex];
                if (!atom) return;
                
                // Create a simple prompt for element selection (in a real app, this would be a modal)
                const currentElement = atom.element;
                const newElement = prompt(`Alterar elemento do átomo de ${currentElement} para:`, currentElement);
                
                if (newElement && newElement !== currentElement && newElement.length <= 2) {
                    // Update atom element
                    atom.element = newElement;
                    
                    // Update atom color based on new element
                    const elementColor = getElementColor(newElement);
                    if (atom.mesh) {
                        atom.mesh.material.color.setHex(elementColor);
                    }
                    
                    // Update atom label
                    if (atom.sprite) {
                        scene.remove(atom.sprite);
                        createAtomLabel(atomIndex);
                    }
                    
                    updateCounts();
                }
            }
            
            function optimizeGeometry() {
                // Show loading overlay
                loadingOverlay.classList.remove('hidden');
                
                setTimeout(() => {
                    // Primeiro, tentar detectar se é uma estrutura conhecida
                    const detectedMolecule = detectKnownMolecule();
                    
                    if (detectedMolecule) {
                        // Se for uma estrutura conhecida, reorganizar para a geometria correta
                        reorganizeToKnownStructure(detectedMolecule);
                        showMoleculeAlert(detectedMolecule);
                    } else {
                        // Se não for conhecida, aplicar otimização geral
                        applyGeneralOptimization();
                    }
                    
                    // Atualizar visualizações
                    updateMoleculeVisuals();
                    
                    // Hide loading overlay
                    loadingOverlay.classList.add('hidden');
                }, 1000);
            }

            // Função para reorganizar para estrutura conhecida
            function reorganizeToKnownStructure(moleculeInfo) {
                const formula = getMolecularFormula();
                
                // Limpar posições atuais
                molecules.atoms.forEach(atom => {
                    atom.position.set(0, 0, 0);
                });
                
                // Aplicar geometria específica baseada na estrutura
                switch (formula) {
                    case 'H2O':
                        reorganizeWater();
                        break;
                    case 'CO2':
                        reorganizeCO2();
                        break;
                    case 'CH4':
                        reorganizeMethane();
                        break;
                    case 'NH3':
                        reorganizeAmmonia();
                        break;
                    case 'C2H4':
                        reorganizeEthylene();
                        break;
                    case 'C2H2':
                        reorganizeAcetylene();
                        break;
                    case 'O2':
                    case 'N2':
                    case 'HCl':
                        reorganizeLinear();
                        break;
                    case 'C6H6':
                        reorganizeBenzene();
                        break;
                    case 'C2H6':
                        reorganizeEthane();
                        break;
                    case 'C3H8':
                        reorganizePropane();
                        break;
                    case 'C4H10':
                        reorganizeButane();
                        break;
                    case 'CH3OH':
                        reorganizeMethanol();
                        break;
                    case 'C2H5OH':
                        reorganizeEthanol();
                        break;
                    default:
                        // Para estruturas não reconhecidas, aplicar otimização geral
                        applyGeneralOptimization();
                }
            }

            // Função para otimização geral (para estruturas não reconhecidas)
            function applyGeneralOptimization() {
                // Aplicar forças de mola para ajustar comprimentos de ligação
                for (let i = 0; i < 10; i++) {
                    molecules.bonds.forEach(bond => {
                        const atom1 = molecules.atoms[bond.atom1];
                        const atom2 = molecules.atoms[bond.atom2];
                        
                        if (!atom1 || !atom2) return;
                        
                        let idealLength;
                        if (bond.order === 1) {
                            idealLength = molecularGeometry.bondLengths.default;
                        } else if (bond.order === 2) {
                            idealLength = molecularGeometry.bondLengths.default * 0.9;
                        } else if (bond.order === 3) {
                            idealLength = molecularGeometry.bondLengths.default * 0.8;
                        }
                        
                        const direction = new THREE.Vector3().subVectors(atom2.position, atom1.position);
                        const currentLength = direction.length();
                        direction.normalize();
                        
                        const forceMagnitude = (currentLength - idealLength) * 0.5;
                        const force = direction.clone().multiplyScalar(forceMagnitude);
                        
                        if (atom1.element !== 'H') {
                            atom1.position.add(force);
                        }
                        if (atom2.element !== 'H') {
                            atom2.position.sub(force);
                        }
                    });
                }
            }

            // Função para atualizar visualizações
            function updateMoleculeVisuals() {
                // Atualizar posições dos meshes
                molecules.atoms.forEach(atom => {
                    if (atom.mesh) {
                        atom.mesh.position.copy(atom.position);
                    }
                    if (atom.sprite) {
                        atom.sprite.position.copy(atom.position);
                    }
                });
                
                // Atualizar ligações
                molecules.bonds.forEach(bond => {
                    updateBondVisual(bond);
                });
                
                // Se estiver no modo 2D, converter e redesenhar
                if (state.viewMode === '2D') {
                    convert3Dto2D();
                    draw2D();
                }
            }

            // Funções específicas para reorganizar cada estrutura
            function reorganizeWater() {
                const O = molecules.atoms.find(a => a.element === 'O');
                const H1 = molecules.atoms.find(a => a.element === 'H' && a !== O);
                const H2 = molecules.atoms.find(a => a.element === 'H' && a !== H1 && a !== O);
                
                if (O && H1 && H2) {
                    O.position.set(0, 0, 0);
                    const bondLength = 0.96;
                    const angle = 104.5 * Math.PI / 180;
                    H1.position.set(bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                    H2.position.set(-bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                }
            }

            function reorganizeCO2() {
                const C = molecules.atoms.find(a => a.element === 'C');
                const O1 = molecules.atoms.find(a => a.element === 'O' && a !== C);
                const O2 = molecules.atoms.find(a => a.element === 'O' && a !== O1 && a !== C);
                
                if (C && O1 && O2) {
                    C.position.set(0, 0, 0);
                    const bondLength = 1.16;
                    O1.position.set(-bondLength, 0, 0);
                    O2.position.set(bondLength, 0, 0);
                }
            }

            function reorganizeMethane() {
                const C = molecules.atoms.find(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (C && Hs.length === 4) {
                    C.position.set(0, 0, 0);
                    const bondLength = 1.09;
                    
                    // Posições tetraédricas
                    Hs[0].position.set(bondLength, bondLength, bondLength);
                    Hs[1].position.set(-bondLength, -bondLength, bondLength);
                    Hs[2].position.set(-bondLength, bondLength, -bondLength);
                    Hs[3].position.set(bondLength, -bondLength, -bondLength);
                    
                    // Normalizar para o comprimento correto
                    Hs.forEach(H => {
                        H.position.normalize().multiplyScalar(bondLength);
                    });
                }
            }

            function reorganizeAmmonia() {
                const N = molecules.atoms.find(a => a.element === 'N');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (N && Hs.length === 3) {
                    N.position.set(0, 0, 0);
                    const bondLength = 1.01;
                    const angle = 107 * Math.PI / 180;
                    
                    // Geometria piramidal trigonal
                    Hs[0].position.set(0, bondLength * Math.cos(angle/2), bondLength * Math.sin(angle/2));
                    Hs[1].position.set(bondLength * Math.sin(angle/2) * Math.cos(2*Math.PI/3), 
                                      bondLength * Math.cos(angle/2), 
                                      bondLength * Math.sin(angle/2) * Math.sin(2*Math.PI/3));
                    Hs[2].position.set(bondLength * Math.sin(angle/2) * Math.cos(4*Math.PI/3), 
                                      bondLength * Math.cos(angle/2), 
                                      bondLength * Math.sin(angle/2) * Math.sin(4*Math.PI/3));
                }
            }

            function reorganizeEthylene() {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === 2 && Hs.length === 4) {
                    const ccLength = 1.34;
                    const chLength = 1.08;
                    const angle = 120 * Math.PI / 180;
                    
                    Cs[0].position.set(-ccLength/2, 0, 0);
                    Cs[1].position.set(ccLength/2, 0, 0);
                    
                    Hs[0].position.set(-ccLength/2 - chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                    Hs[1].position.set(-ccLength/2 - chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                    Hs[2].position.set(ccLength/2 + chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                    Hs[3].position.set(ccLength/2 + chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                }
            }

            function reorganizeAcetylene() {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === 2 && Hs.length === 2) {
                    const ccLength = 1.20;
                    const chLength = 1.06;
                    
                    Cs[0].position.set(-ccLength/2, 0, 0);
                    Cs[1].position.set(ccLength/2, 0, 0);
                    Hs[0].position.set(-ccLength/2 - chLength, 0, 0);
                    Hs[1].position.set(ccLength/2 + chLength, 0, 0);
                }
            }

            function reorganizeLinear() {
                const atoms = molecules.atoms;
                if (atoms.length === 2) {
                    const bondLength = 1.2;
                    atoms[0].position.set(-bondLength/2, 0, 0);
                    atoms[1].position.set(bondLength/2, 0, 0);
                }
            }

            function reorganizeBenzene() {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === 6 && Hs.length === 6) {
                    const radius = 1.40;
                    const chLength = 1.08;
                    
                    // Posicionar carbonos em hexágono
                    Cs.forEach((C, i) => {
                        const angle = (i * Math.PI) / 3;
                        C.position.set(radius * Math.cos(angle), radius * Math.sin(angle), 0);
                    });
                    
                    // Posicionar hidrogênios
                    Hs.forEach((H, i) => {
                        const angle = (i * Math.PI) / 3;
                        H.position.set((radius + chLength) * Math.cos(angle), (radius + chLength) * Math.sin(angle), 0);
                    });
                }
            }

            function reorganizeEthane() {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === 2 && Hs.length === 6) {
                    const ccLength = 1.54;
                    const chLength = 1.09;
                    
                    Cs[0].position.set(-ccLength/2, 0, 0);
                    Cs[1].position.set(ccLength/2, 0, 0);
                    
                    // Hidrogênios em posições tetraédricas
                    const tetrahedralPositions = [
                        [1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]
                    ];
                    
                    tetrahedralPositions.forEach((pos, i) => {
                        const H = Hs[i];
                        const direction = new THREE.Vector3(pos[0], pos[1], pos[2]).normalize();
                        H.position.copy(Cs[0].position).add(direction.multiplyScalar(chLength));
                    });
                    
                    tetrahedralPositions.forEach((pos, i) => {
                        const H = Hs[i + 4];
                        const direction = new THREE.Vector3(pos[0], pos[1], pos[2]).normalize();
                        H.position.copy(Cs[1].position).add(direction.multiplyScalar(chLength));
                    });
                }
            }

            function reorganizePropane() { reorganizeAlkane(3); }
            function reorganizeButane() { reorganizeAlkane(4); }

            function reorganizeAlkane(carbonCount) {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === carbonCount) {
                    const ccLength = 1.54;
                    const chLength = 1.09;
                    
                    // Posicionar carbonos em linha
                    Cs.forEach((C, i) => {
                        C.position.set((i - (carbonCount-1)/2) * ccLength, 0, 0);
                    });
                    
                    // Posicionar hidrogênios (simplificado)
                    let hIndex = 0;
                    Cs.forEach((C, i) => {
                        const isTerminal = (i === 0 || i === carbonCount-1);
                        const hCount = isTerminal ? 3 : 2;
                        
                        for (let j = 0; j < hCount && hIndex < Hs.length; j++) {
                            const angle = (j * 2 * Math.PI) / hCount;
                            const H = Hs[hIndex++];
                            H.position.set(
                                C.position.x + chLength * Math.cos(angle),
                                C.position.y + chLength * Math.sin(angle),
                                C.position.z
                            );
                        }
                    });
                }
            }

            function reorganizeMethanol() {
                const C = molecules.atoms.find(a => a.element === 'C');
                const O = molecules.atoms.find(a => a.element === 'O');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (C && O && Hs.length === 4) {
                    C.position.set(0, 0, 0);
                    O.position.set(1.43, 0, 0);
                    
                    // Hidrogênios do carbono
                    Hs[0].position.set(-1.09, 1.09, 0);
                    Hs[1].position.set(-1.09, -1.09, 0);
                    Hs[2].position.set(-1.09, 0, 1.09);
                    
                    // Hidrogênio do oxigênio
                    Hs[3].position.set(2.52, 0, 0);
                }
            }

            function reorganizeEthanol() {
                const Cs = molecules.atoms.filter(a => a.element === 'C');
                const O = molecules.atoms.find(a => a.element === 'O');
                const Hs = molecules.atoms.filter(a => a.element === 'H');
                
                if (Cs.length === 2 && O && Hs.length === 6) {
                    Cs[0].position.set(0, 0, 0);
                    Cs[1].position.set(1.54, 0, 0);
                    O.position.set(2.43, 0, 0);
                    
                    // Hidrogênios (simplificado)
                    Hs[0].position.set(-1.09, 1.09, 0);
                    Hs[1].position.set(-1.09, -1.09, 0);
                    Hs[2].position.set(-1.09, 0, 1.09);
                    Hs[3].position.set(2.54, 1.09, 0);
                    Hs[4].position.set(2.54, -1.09, 0);
                    Hs[5].position.set(3.52, 0, 0);
                }
            }
            
            function addHydrogens() {
                // Implementação avançada: adicionar hidrogênios com base nas regras de valência
                // e estrutura 3D da molécula
                
                // Mostrar overlay de carregamento
                loadingOverlay.classList.remove('hidden');
                
                setTimeout(() => {
                const newAtoms = [];
                
                    // Valências comuns para elementos
                    const valences = {
                        'C': 4,  // Carbono: 4 ligações
                        'N': 3,  // Nitrogênio: 3 ligações
                        'O': 2,  // Oxigênio: 2 ligações
                        'H': 1,  // Hidrogênio: 1 ligação
                        'F': 1,  // Flúor: 1 ligação
                        'Cl': 1, // Cloro: 1 ligação
                        'Br': 1, // Bromo: 1 ligação
                        'I': 1,  // Iodo: 1 ligação
                        'S': 2,  // Enxofre: geralmente 2 ligações (simplificado)
                        'P': 3,  // Fósforo: geralmente 3 ligações (simplificado)
                        'default': 1
                    };
                    
                    // Comprimentos ideais de ligação com hidrogênio
                    const hBondLengths = {
                        'C': 1.1,
                        'N': 1.0,
                        'O': 0.96,
                        'S': 1.3,
                        'P': 1.4,
                        'default': 1.1
                    };
                    
                    // Para cada átomo não-hidrogênio
                molecules.atoms.forEach((atom, i) => {
                        if (atom.element === 'H') return; // Pular hidrogênios
                    
                        // Contar ligações existentes e identificar átomos vizinhos
                        const connectedBonds = molecules.bonds.filter(b => 
                        b.atom1 === i || b.atom2 === i
                        );
                        
                        const connectedAtoms = connectedBonds.map(bond => {
                            const otherIndex = bond.atom1 === i ? bond.atom2 : bond.atom1;
                            return {
                                index: otherIndex,
                                atom: molecules.atoms[otherIndex],
                                bondOrder: bond.order
                            };
                        });
                        
                        // Calcular valência total usada (considerando ordens de ligação)
                        const usedValence = connectedBonds.reduce((sum, bond) => sum + bond.order, 0);
                        
                        // Determinar quantos hidrogênios adicionar
                        const maxValence = valences[atom.element] || valences.default;
                        let hydrogensToAdd = Math.max(0, maxValence - usedValence);
                        
                        // Se for um carbono com ligação dupla ou tripla, ajustar geometria
                        let geometry = 'tetrahedral'; // Padrão para carbono sp3
                        
                        if (atom.element === 'C') {
                            if (connectedBonds.some(b => b.order === 2)) {
                                geometry = 'trigonal'; // sp2 (120°)
                            } else if (connectedBonds.some(b => b.order === 3)) {
                                geometry = 'linear'; // sp (180°)
                            }
                        } else if (atom.element === 'N' || atom.element === 'O') {
                            geometry = 'bent'; // Geometria angular
                        }
                        
                        // Adicionar hidrogênios com base na geometria
                        if (hydrogensToAdd > 0) {
                            // Determinar posições para os hidrogênios com base na geometria e átomos vizinhos
                            let positions = [];
                            
                            // Comprimento de ligação para este elemento
                            const bondLength = hBondLengths[atom.element] || hBondLengths.default;
                            
                            // Calcular direções para evitar (direções de átomos já conectados)
                            const avoidDirections = connectedAtoms.map(connected => {
                                return new THREE.Vector3().subVectors(
                                    connected.atom.position,
                                    atom.position
                                ).normalize();
                            });
                            
                            // Gerar posições baseadas na geometria
                            switch (geometry) {
                                case 'tetrahedral': // sp3 - ângulo ~109.5°
                                    // Gerar pontos em um tetraedro
                                    positions = distributePointsOnTetrahedron(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'trigonal': // sp2 - ângulo 120°
                                    // Gerar pontos em um plano com ângulos de 120°
                                    positions = distributePointsOnTrigonal(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'linear': // sp - ângulo 180°
                                    // Gerar pontos em linha reta
                                    positions = distributePointsOnLine(hydrogensToAdd, bondLength, avoidDirections);
                            break;
                                    
                                case 'bent': // Geometria angular (para O, N)
                                    // Ângulo aproximado de 104.5° para O, 107° para N
                                    const angle = atom.element === 'O' ? 104.5 : 107;
                                    positions = distributePointsOnBent(hydrogensToAdd, bondLength, avoidDirections, angle);
                            break;
                                    
                        default:
                                    // Distribuição uniforme na esfera
                                    positions = distributePointsOnSphere(hydrogensToAdd, bondLength);
                    }
                    
                            // Adicionar os hidrogênios nas posições calculadas
                        positions.forEach(pos => {
                            const hydrogenPos = atom.position.clone().add(pos);
                            const hIndex = addAtom('H', hydrogenPos.x, hydrogenPos.y, hydrogenPos.z);
                            addBond(i, hIndex, 1);
                            newAtoms.push(hIndex);
                        });
                    }
                });
                
                    // Otimizar geometria para espalhar novos hidrogênios
                if (newAtoms.length > 0) {
                    optimizeGeometry();
                    } else {
                        // Esconder overlay de carregamento se não houver otimização
                        loadingOverlay.classList.add('hidden');
                }
                
                updateCounts();
                }, 100);
            }
            
            // Funções auxiliares para distribuir hidrogênios em diferentes geometrias
            function distributePointsOnTetrahedron(count, radius, avoidDirections = []) {
                // Vértices de um tetraedro regular
                const tetrahedronVertices = [
                    new THREE.Vector3(1, 1, 1),
                    new THREE.Vector3(-1, -1, 1),
                    new THREE.Vector3(-1, 1, -1),
                    new THREE.Vector3(1, -1, -1)
                ];
                
                // Normalizar vértices
                tetrahedronVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = tetrahedronVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnTrigonal(count, radius, avoidDirections = []) {
                // Pontos em um plano com ângulos de 120°
                const trigonalVertices = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(-0.5, 0.866, 0),
                    new THREE.Vector3(-0.5, -0.866, 0)
                ];
                
                // Normalizar vértices
                trigonalVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = trigonalVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnLine(count, radius, avoidDirections = []) {
                // Pontos em linha reta (180°)
                const lineVertices = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(-1, 0, 0)
                ];
                
                // Normalizar vértices
                lineVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = lineVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnBent(count, radius, avoidDirections = [], angle = 104.5) {
                // Converter ângulo para radianos
                const angleRad = angle * Math.PI / 180;
                
                // Pontos em geometria angular
                const bentVertices = [
                    new THREE.Vector3(Math.sin(angleRad/2), Math.cos(angleRad/2), 0),
                    new THREE.Vector3(-Math.sin(angleRad/2), Math.cos(angleRad/2), 0)
                ];
                
                // Normalizar vértices
                bentVertices.forEach(v => v.normalize().multiplyScalar(radius));
                
                // Filtrar direções a evitar
                const availableVertices = bentVertices.filter(vertex => {
                    return !avoidDirections.some(dir => {
                        return vertex.clone().normalize().dot(dir) > 0.8; // Ângulo < ~35°
                    });
                });
                
                // Se não houver vértices disponíveis suficientes, gerar aleatoriamente
                if (availableVertices.length < count) {
                    return distributePointsOnSphere(count, radius, avoidDirections);
                }
                
                // Retornar os vértices disponíveis necessários
                return availableVertices.slice(0, count);
            }
            
            function distributePointsOnSphere(count, radius, avoidDirections = []) {
                if (count <= 0) return [];
                
                // Gerar mais pontos do que o necessário para ter opções
                const candidateCount = Math.max(count * 3, 12);
                const candidates = [];
                const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle
                
                for (let i = 0; i < candidateCount; i++) {
                    const y = 1 - (i / (candidateCount - 1)) * 2;
                    const radiusAtY = Math.sqrt(1 - y * y);
                    
                    const theta = phi * i;
                    
                    const x = Math.cos(theta) * radiusAtY;
                    const z = Math.sin(theta) * radiusAtY;
                    
                    candidates.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
                }
                
                // Se não houver direções a evitar, retornar os pontos distribuídos uniformemente
                if (avoidDirections.length === 0 || count >= candidateCount) {
                    return candidates.slice(0, count);
                }
                
                // Filtrar candidatos para evitar direções específicas
                const filteredCandidates = candidates.filter(point => {
                    const direction = point.clone().normalize();
                    return !avoidDirections.some(dir => direction.dot(dir) > 0.8); // Ângulo < ~35°
                });
                
                // Se não houver candidatos suficientes após filtragem, adicionar pontos aleatórios
                if (filteredCandidates.length < count) {
                    while (filteredCandidates.length < count) {
                        // Gerar ponto aleatório na esfera
                        const randomPoint = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1
                        ).normalize().multiplyScalar(radius);
                        
                        // Verificar se não está muito próximo das direções a evitar
                        const direction = randomPoint.clone().normalize();
                        const tooClose = avoidDirections.some(dir => direction.dot(dir) > 0.7);
                        
                        if (!tooClose) {
                            filteredCandidates.push(randomPoint);
                        }
                    }
                }
                
                // Selecionar os pontos mais bem distribuídos
                // Para simplificar, vamos pegar os primeiros 'count' pontos
                return filteredCandidates.slice(0, count);
            }
            
            function updateCounts() {
                atomCount.textContent = molecules.atoms.length;
                bondCount.textContent = molecules.bonds.length;
            }
            
            // Viewport interaction
            function onMouseDown(event) {
                event.preventDefault();
                
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                
                // Verificar se está no modo de rotação
                if (state.currentTool === 'rotate') {
                    // Iniciar rotação manual
                    state.rotation.active = true;
                    state.rotation.startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    
                    // Verificar se clicou em algum átomo para rotacionar em torno dele
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    if (intersects.length > 0) {
                        const object = intersects[0].object;
                        if (object.userData.atomIndex !== undefined) {
                            // Usar o átomo como centro de rotação
                            const atom = molecules.atoms[object.userData.atomIndex];
                            if (atom) {
                                state.rotation.center.copy(atom.position);
                                
                                // Destacar o átomo como centro de rotação
                                atom.mesh.material.emissive.setHex(0x00ffff);
                                setTimeout(() => {
                                    atom.mesh.material.emissive.setHex(0x000000);
                                }, 500);
                            }
                        }
                    } else {
                        // Usar o centro da molécula como centro de rotação
                        state.rotation.center.set(0, 0, 0);
                    }
                } else {
                    // Para outras ferramentas, continuar com o comportamento normal
                handleInteraction();
                }
            }
            
            function onMouseMove(event) {
                // Atualizar posição do mouse independentemente do estado
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                
                // Show atom preview if in atom tool mode
                if (state.currentTool === 'atom' && state.viewMode === '3D') {
                    const position = calculateOptimalAtomPosition();
                    const nearbyAtom = findNearbyAtomForBonding(position);
                    showAtomPreview(position, nearbyAtom);
                }
                
                // Move atom if in moving mode
                if (state.atomEditing.isMoving && state.viewMode === '3D') {
                    const position = calculateOptimalAtomPosition();
                    moveAtomToPosition(position);
                }
                
                // Se estiver no modo de rotação e rotação ativa
                if (state.currentTool === 'rotate' && state.rotation.active) {
                    // Calcular diferença de posição do mouse
                    const deltaX = event.clientX - state.rotation.startPoint.x;
                    const deltaY = event.clientY - state.rotation.startPoint.y;
                    
                    // Sensibilidade da rotação
                    const rotationSpeed = 0.01;
                    
                    // Criar quaternions para rotação
                    const quaternionX = new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(0, 1, 0), // Eixo Y para rotação horizontal
                        deltaX * rotationSpeed
                    );
                    
                    const quaternionY = new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(1, 0, 0), // Eixo X para rotação vertical
                        deltaY * rotationSpeed
                    );
                    
                    // Combinar rotações
                    const combinedQuaternion = new THREE.Quaternion().multiplyQuaternions(quaternionX, quaternionY);
                    
                    // Aplicar rotação a todos os átomos em relação ao centro
                    molecules.atoms.forEach(atom => {
                        if (!atom.mesh) return;
                        
                        // Calcular posição relativa ao centro de rotação
                        const relativePos = atom.position.clone().sub(state.rotation.center);
                        
                        // Aplicar rotação
                        relativePos.applyQuaternion(combinedQuaternion);
                        
                        // Calcular nova posição
                        const newPos = relativePos.add(state.rotation.center);
                        
                        // Atualizar posição
                        atom.position.copy(newPos);
                        atom.mesh.position.copy(newPos);
                    });
                    
                    // Atualizar ligações
                    molecules.bonds.forEach(bond => {
                        updateBondVisual(bond);
                    });
                    
                    // Atualizar ponto inicial para próxima rotação
                    state.rotation.startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
                // Se estiver desenhando uma ligação
                else if (state.currentTool === 'bond' && state.isDrawing && state.tempBond) {
                    // Atualizar posição da linha temporária
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Calcular ponto no espaço 3D
                    const planeNormal = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const plane = new THREE.Plane(planeNormal, -5);
                    const endPoint = new THREE.Vector3();
                    
                    if (raycaster.ray.intersectPlane(plane, endPoint)) {
                        // Atualizar a geometria da linha
                        const points = [state.tempBond.startPosition, endPoint];
                        state.tempBond.line.geometry.setFromPoints(points);
                        state.tempBond.line.computeLineDistances();
                        
                        // Verificar se está sobre outro átomo
                        const intersects = raycaster.intersectObjects(scene.children);
                        for (let i = 0; i < intersects.length; i++) {
                            const object = intersects[i].object;
                            if (object.userData.atomIndex !== undefined && 
                                object.userData.atomIndex !== state.tempBond.startAtom) {
                                // Destacar átomo alvo
                                const atom = molecules.atoms[object.userData.atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x00ff00);
                                }
                                break;
                            }
                        }
                    }
                }
            }
            
            function onMouseUp(event) {
                // Verificar se está no modo de rotação
                if (state.currentTool === 'rotate' && state.rotation.active) {
                    // Finalizar rotação
                    state.rotation.active = false;
                    state.rotation.startPoint = null;
                    return;
                } else if (state.atomEditing.isMoving) {
                    // Finalize atom movement
                    stopMovingAtom();
                }
                
                // Se não estiver desenhando, não faz nada
                if (!state.isDrawing) return;
                
                // Finalizar desenho
                state.isDrawing = false;
                
                // Verificar se está no modo de ligação
                if (state.currentTool === 'bond' && state.tempBond) {
                    // Verificar se o mouse está sobre outro átomo
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    let foundAtom = false;
                    for (let i = 0; i < intersects.length; i++) {
                        const object = intersects[i].object;
                        if (object.userData.atomIndex !== undefined && 
                            object.userData.atomIndex !== state.tempBond.startAtom) {
                            
                            // Criar ligação entre os dois átomos
                            addBond(state.tempBond.startAtom, object.userData.atomIndex, state.currentBond);
                            updateCounts();
                            
                            // Remover destaque
                            const atom = molecules.atoms[object.userData.atomIndex];
                            if (atom && atom.mesh) {
                                atom.mesh.material.emissive.setHex(0x000000);
                            }
                            
                            foundAtom = true;
                            break;
                        }
                    }
                    
                    // Remover linha temporária
                    if (state.tempBond.line) {
                        scene.remove(state.tempBond.line);
                    }
                    
                    // Limpar seleção se não encontrou átomo
                    if (!foundAtom) {
                        state.selectedAtoms.forEach(idx => {
                            const atom = molecules.atoms[idx];
                            if (atom && atom.mesh) {
                                atom.mesh.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                    
                    state.tempBond = null;
                    state.selectedAtoms = [];
                }
            }
            
            function onTouchStart(event) {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;
                    
                    handleInteraction();
                }
            }
            
            function onTouchMove(event) {
                event.preventDefault();
                
                if (event.touches.length === 1 && state.isDrawing) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;
                    
                    if (state.currentTool === 'bond' && state.tempBond) {
                        // Update temporary bond position
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(scene.children);
                        
                        if (intersects.length > 0) {
                            const point = intersects[0].point;
                            state.tempBond.position.copy(point);
                        }
                    }
                }
            }
            
            function onTouchEnd(event) {
                event.preventDefault();
                state.isDrawing = false;
                
                if (state.currentTool === 'bond' && state.tempBond) {
                    // Remove temporary bond indicator
                    scene.remove(state.tempBond);
                    state.tempBond = null;
                }
            }
            
            function handleInteraction() {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    // Debug: log object information
                    console.log('Clicked object:', object);
                    console.log('Object userData:', object.userData);
                    console.log('Current tool:', state.currentTool);
                    
                    // Skip preview objects
                    if (object.userData.isPreview || object.userData.isMovePreview) {
                        return;
                    }
                    
                    switch(state.currentTool) {
                        case 'select':
                            // Highlight selected atom
                            let selectAtomIndex = null;
                            
                            // Check if it's an atom mesh
                            if (object.userData.atomIndex !== undefined) {
                                selectAtomIndex = object.userData.atomIndex;
                            }
                            // Check if it's an atom sprite
                            else if (object.parent && object.parent.userData && object.parent.userData.atomIndex !== undefined) {
                                selectAtomIndex = object.parent.userData.atomIndex;
                            }
                            // Check if it's part of a bond (skip bonds)
                            else if (object.parent && object.parent.userData && object.parent.userData.isBond) {
                                return;
                            }
                            
                            if (selectAtomIndex !== null) {
                                // Clear previous selection
                                state.selectedAtoms.forEach(index => {
                                    const atom = molecules.atoms[index];
                                    if (atom && atom.mesh) {
                                        atom.mesh.material.emissive.setHex(0x000000);
                                    }
                                });
                                
                                state.selectedAtoms = [selectAtomIndex];
                                
                                // Highlight new selection
                                const atom = molecules.atoms[selectAtomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x333333);
                                }
                            }
                            break;
                            
                        case 'move':
                            // Select atom for moving
                            let atomIndex = null;
                            
                            // Check if it's an atom mesh
                            if (object.userData.atomIndex !== undefined) {
                                atomIndex = object.userData.atomIndex;
                            }
                            // Check if it's an atom sprite
                            else if (object.parent && object.parent.userData && object.parent.userData.atomIndex !== undefined) {
                                atomIndex = object.parent.userData.atomIndex;
                            }
                            // Check if it's part of a bond (skip bonds)
                            else if (object.parent && object.parent.userData && object.parent.userData.isBond) {
                                return;
                            }
                            
                            if (atomIndex !== null) {
                                // Clear previous selection
                                state.selectedAtoms.forEach(index => {
                                    const atom = molecules.atoms[index];
                                    if (atom && atom.mesh) {
                                        atom.mesh.material.emissive.setHex(0x000000);
                                    }
                                });
                                
                                // Select atom for moving
                                state.atomEditing.selectedAtom = atomIndex;
                                state.selectedAtoms = [atomIndex];
                                
                                // Highlight selected atom
                                const atom = molecules.atoms[atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x00ff00);
                                }
                                
                                // Start moving
                                startMovingAtom();
                            }
                            break;
                            
                        case 'atom':
                            // Add new atom at clicked position
                            const element = state.currentAtom;
                            const position = intersects[0].point;
                            addAtom(element, position.x, position.y, position.z);
                            updateCounts();
                            break;
                            
                        case 'bond':
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                
                                // Destacar o átomo selecionado
                                const atom = molecules.atoms[atomIndex];
                                if (atom && atom.mesh) {
                                    // Remover destaque anterior
                                    state.selectedAtoms.forEach(idx => {
                                        const prevAtom = molecules.atoms[idx];
                                        if (prevAtom && prevAtom.mesh) {
                                            prevAtom.mesh.material.emissive.setHex(0x000000);
                                        }
                                    });
                                    
                                    // Destacar o novo átomo
                                    atom.mesh.material.emissive.setHex(0x00ff00);
                                }
                                
                                if (state.selectedAtoms.length === 0) {
                                    // Primeiro átomo selecionado
                                    state.selectedAtoms = [atomIndex];
                                    
                                    // Criar indicador temporário de ligação
                                    const lineGeometry = new THREE.BufferGeometry();
                                    const lineMaterial = new THREE.LineDashedMaterial({
                                        color: 0x00ff00,
                                        dashSize: 0.2,
                                        gapSize: 0.1,
                                        linewidth: 2
                                    });
                                    
                                    // Inicializar com dois pontos iguais (será atualizado no mousemove)
                                    const points = [atom.position.clone(), atom.position.clone()];
                                    lineGeometry.setFromPoints(points);
                                    
                                    const line = new THREE.Line(lineGeometry, lineMaterial);
                                    line.computeLineDistances(); // Necessário para linhas tracejadas
                                    scene.add(line);
                                    
                                    state.tempBond = {
                                        line: line,
                                        startAtom: atomIndex,
                                        startPosition: atom.position.clone()
                                    };
                                    state.isDrawing = true;
                                    
                                } else if (state.selectedAtoms.length === 1 && 
                                          state.selectedAtoms[0] !== atomIndex) {
                                    // Segundo átomo selecionado - criar ligação
                                    addBond(state.selectedAtoms[0], atomIndex, state.currentBond);
                                    
                                    // Limpar seleção e remover linha temporária
                                    if (state.tempBond && state.tempBond.line) {
                                        scene.remove(state.tempBond.line);
                                    }
                                    state.tempBond = null;
                                    state.selectedAtoms = [];
                                    state.isDrawing = false;
                                    
                                    // Remover destaque
                                    atom.mesh.material.emissive.setHex(0x000000);
                                    
                                    updateCounts();
                                }
                            }
                            break;
                            
                        case 'erase':
                            // Verificar se clicou em um átomo
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                
                                // Destacar o átomo antes de remover (feedback visual)
                                const atom = molecules.atoms[atomIndex];
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0xff0000);
                                }
                                
                                // Pequeno atraso para mostrar o destaque antes de remover
                                setTimeout(() => {
                                    removeAtom(atomIndex);
                                updateCounts();
                                }, 100);
                            }
                            // Verificar se clicou em uma ligação
                            else {
                                // Percorrer todas as ligações para ver se alguma foi clicada
                                for (let i = 0; i < molecules.bonds.length; i++) {
                                    const bond = molecules.bonds[i];
                                    
                                    // Verificar se o objeto clicado é parte da ligação
                                    if (bond.mesh === object || 
                                        (bond.mesh && bond.mesh.children && 
                                         bond.mesh.children.includes(object))) {
                                        
                                        // Destacar a ligação antes de remover
                                        if (bond.mesh) {
                                            if (bond.mesh.children) {
                                                bond.mesh.children.forEach(child => {
                                                    if (child.material) {
                                                        child.material.emissive = new THREE.Color(0xff0000);
                                                    }
                                                });
                                            } else if (bond.mesh.material) {
                                                bond.mesh.material.emissive = new THREE.Color(0xff0000);
                                            }
                                        }
                                        
                                        // Pequeno atraso para mostrar o destaque antes de remover
                                        setTimeout(() => {
                                            removeBond(i);
                                            updateCounts();
                                        }, 100);
                                        
                                        break;
                                    }
                                }
                            }
                            break;
                            
                        case 'measure':
                            if (object.userData.atomIndex !== undefined) {
                                const atomIndex = object.userData.atomIndex;
                                const atom = molecules.atoms[atomIndex];
                                
                                // Destacar o átomo selecionado
                                if (atom && atom.mesh) {
                                    atom.mesh.material.emissive.setHex(0x0000ff); // Azul para medição
                                }
                                
                                // Adicionar ponto à medição
                                state.measurement.active = true;
                                state.measurement.points.push({
                                    position: atom.position.clone(),
                                    atomIndex: atomIndex
                                });
                                
                                // Se já temos dois pontos, calcular a distância
                                if (state.measurement.points.length === 2) {
                                    // Calcular distância entre os dois pontos
                                    const distance = state.measurement.points[0].position.distanceTo(state.measurement.points[1].position);
                                    distanceValue.textContent = distance.toFixed(2);
                                    measurementDisplay.classList.remove('hidden');
                                    
                                    // Criar linha visual para mostrar a medição
                                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                        state.measurement.points[0].position,
                                        state.measurement.points[1].position
                                    ]);
                                    
                                    const lineMaterial = new THREE.LineDashedMaterial({
                                        color: 0x0000ff,
                                        dashSize: 0.2,
                                        gapSize: 0.1,
                                        linewidth: 2
                                    });
                                    
                                    // Remover linha de medição anterior, se existir
                                    if (state.measurement.line) {
                                        scene.remove(state.measurement.line);
                                    }
                                    
                                    const line = new THREE.Line(lineGeometry, lineMaterial);
                                    line.computeLineDistances();
                                    scene.add(line);
                                    
                                    // Armazenar linha para poder removê-la depois
                                    state.measurement.line = line;
                                    
                                    // Adicionar texto com a distância no meio da linha
                                    const midPoint = new THREE.Vector3().addVectors(
                                        state.measurement.points[0].position,
                                        state.measurement.points[1].position
                                    ).multiplyScalar(0.5);
                                    
                                    // Resetar pontos para próxima medição, mas manter a linha
                                    setTimeout(() => {
                                        // Remover destaque dos átomos
                                        state.measurement.points.forEach(point => {
                                            const atom = molecules.atoms[point.atomIndex];
                                            if (atom && atom.mesh) {
                                                atom.mesh.material.emissive.setHex(0x000000);
                                            }
                                        });
                                        
                                        // Limpar pontos para próxima medição
                                    state.measurement.points = [];
                                    }, 1000);
                                }
                            }
                            break;
                    }
                } else if (state.currentTool === 'atom') {
                    // Add atom in 3D space with improved positioning
                    const element = state.currentAtom;
                    
                    // Calculate optimal position
                    const position = calculateOptimalAtomPosition();
                    
                    // Check if there's a nearby atom for automatic bonding
                    const nearbyAtom = findNearbyAtomForBonding(position);
                    
                    // Add the atom
                    const newAtomIndex = addAtom(element, position.x, position.y, position.z);
                    
                    // If there's a nearby atom, create a bond automatically
                    if (nearbyAtom) {
                        const nearbyIndex = molecules.atoms.findIndex(atom => atom === nearbyAtom);
                        if (nearbyIndex !== -1) {
                            addBond(nearbyIndex, newAtomIndex, 1); // Simple bond by default
                        }
                    }
                    
                    updateCounts();
                }
            }
            
            // Fullscreen
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    container.requestFullscreen().catch(err => {
                        console.error(`Erro ao tentar ativar tela cheia: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
            
            // Export functions
            function exportPNG() {
                // Temporarily hide UI elements
                const sidebar = document.getElementById('sidebar');
                const bottomBar = document.querySelector('.bg-white.p-3.border-t');
                sidebar.style.display = 'none';
                bottomBar.style.display = 'none';
                
                // Render scene without UI
                renderer.render(scene, camera);
                
                // Create download link
                const link = document.createElement('a');
                link.download = 'molecule.png';
                link.href = renderer.domElement.toDataURL('image/png');
                link.click();
                
                // Restore UI elements
                sidebar.style.display = '';
                bottomBar.style.display = '';
            }
            
            function exportOBJ() {
                // Simple OBJ export (would need more complete implementation for production)
                let objContent = "# Mol3D OBJ Export\n";
                let mtlContent = "# Mol3D MTL Export\n";
                
                // Add atoms as spheres (simplified as vertices)
                molecules.atoms.forEach((atom, i) => {
                    objContent += `v ${atom.position.x} ${atom.position.y} ${atom.position.z}\n`;
                    objContent += `usemtl material_${i}\n`;
                    objContent += `p ${i+1}\n`;
                    
                    // Material (simplified)
                    const color = atomMaterials[atom.element] ? atomMaterials[atom.element].color : atomMaterials['C'].color;
                    mtlContent += `newmtl material_${i}\n`;
                    mtlContent += `Kd ${color.r} ${color.g} ${color.b}\n`;
                });
                
                // Add bonds as lines (simplified)
                molecules.bonds.forEach((bond, i) => {
                    const atom1 = molecules.atoms[bond.atom1];
                    const atom2 = molecules.atoms[bond.atom2];
                    
                    if (atom1 && atom2) {
                        const v1 = molecules.atoms.length + i*2 + 1;
                        const v2 = molecules.atoms.length + i*2 + 2;
                        
                        // Add vertices for bond ends (adjusted for atom radii)
                        const dir = new THREE.Vector3().subVectors(atom2.position, atom1.position).normalize();
                        const start = atom1.position.clone().add(dir.clone().multiplyScalar(0.4));
                        const end = atom2.position.clone().sub(dir.clone().multiplyScalar(0.4));
                        
                        objContent += `v ${start.x} ${start.y} ${start.z}\n`;
                        objContent += `v ${end.x} ${end.y} ${end.z}\n`;
                        objContent += `usemtl bond_material\n`;
                        objContent += `l ${v1} ${v2}\n`;
                    }
                });
                
                // Bond material
                mtlContent += `newmtl bond_material\n`;
                mtlContent += `Kd 0.2 0.2 0.2\n`;
                
                // Combine into a single file
                const fullContent = `${objContent}\n# Materials\n${mtlContent}`;
                
                // Create download link
                const link = document.createElement('a');
                link.download = 'molecule.obj';
                link.href = URL.createObjectURL(new Blob([fullContent], { type: 'text/plain' }));
                link.click();
            }
            
            // Window resize handler
            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                
                // Redimensionar o canvas 2D também
                resizeCanvas();
            }
            
            // 2D Canvas Functions
            
            // Converter coordenadas do mundo para coordenadas de tela
            function worldToScreen(x, y) {
                return {
                    x: x * state.view2D.scale + state.view2D.offsetX,
                    y: y * state.view2D.scale + state.view2D.offsetY
                };
            }
            
            // Converter coordenadas de tela para coordenadas do mundo
            function screenToWorld(x, y) {
                return {
                    x: (x - state.view2D.offsetX) / state.view2D.scale,
                    y: (y - state.view2D.offsetY) / state.view2D.scale
                };
            }
            
            // Aplicar snap à grade
            function snapToGrid(x, y) {
                if (!state.view2D.snapEnabled) return { x, y };
                
                const gridSize = state.view2D.gridSize / state.view2D.scale;
                return {
                    x: Math.round(x / gridSize) * gridSize,
                    y: Math.round(y / gridSize) * gridSize
                };
            }
            
            // Desenhar a grade
            function drawGrid() {
                if (!state.view2D.gridEnabled) return;
                
                const gridSize = state.view2D.gridSize;
                const width = canvas2D.width;
                const height = canvas2D.height;
                
                ctx2D.strokeStyle = '#e5e7eb'; // Cor cinza claro
                ctx2D.lineWidth = 1;
                
                // Linhas verticais
                for (let x = state.view2D.offsetX % gridSize; x < width; x += gridSize) {
                    ctx2D.beginPath();
                    ctx2D.moveTo(x, 0);
                    ctx2D.lineTo(x, height);
                    ctx2D.stroke();
                }
                
                // Linhas horizontais
                for (let y = state.view2D.offsetY % gridSize; y < height; y += gridSize) {
                    ctx2D.beginPath();
                    ctx2D.moveTo(0, y);
                    ctx2D.lineTo(width, y);
                    ctx2D.stroke();
                }
                
                // Desenhar eixos centrais
                ctx2D.strokeStyle = '#9ca3af'; // Cinza médio
                ctx2D.lineWidth = 2;
                
                // Eixo X
                ctx2D.beginPath();
                ctx2D.moveTo(0, state.view2D.offsetY);
                ctx2D.lineTo(width, state.view2D.offsetY);
                ctx2D.stroke();
                
                // Eixo Y
                ctx2D.beginPath();
                ctx2D.moveTo(state.view2D.offsetX, 0);
                ctx2D.lineTo(state.view2D.offsetX, height);
                ctx2D.stroke();
            }
            
            // Desenhar um átomo no canvas 2D
            function drawAtom2D(atom) {
                const pos = worldToScreen(atom.x, atom.y);
                const radius = 20; // Tamanho do átomo em pixels
                
                // Determinar cor do átomo
                let color;
                switch (atom.element) {
                    case 'H': color = '#FFFFFF'; break;
                    case 'C': color = '#909090'; break;
                    case 'O': color = '#FF0D0D'; break;
                    case 'N': color = '#3050F8'; break;
                    case 'S': color = '#FFFF30'; break;
                    case 'P': color = '#FF8000'; break;
                    case 'F': case 'Cl': case 'Br': case 'I': color = '#1FF01F'; break;
                    default: color = '#909090';
                }
                
                // Desenhar círculo
                ctx2D.beginPath();
                ctx2D.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx2D.fillStyle = color;
                ctx2D.fill();
                ctx2D.strokeStyle = '#000000';
                ctx2D.lineWidth = 2;
                ctx2D.stroke();
                
                // Desenhar símbolo do elemento
                ctx2D.font = 'bold 16px Arial';
                ctx2D.fillStyle = atom.element === 'H' || atom.element === 'S' ? '#000000' : '#FFFFFF';
                ctx2D.textAlign = 'center';
                ctx2D.textBaseline = 'middle';
                ctx2D.fillText(atom.element, pos.x, pos.y);
                
                // Destacar se selecionado
                if (atom === state.view2D.selectedAtom) {
                    ctx2D.beginPath();
                    ctx2D.arc(pos.x, pos.y, radius + 5, 0, Math.PI * 2);
                    ctx2D.strokeStyle = '#3b82f6'; // Azul
                    ctx2D.lineWidth = 3;
                    ctx2D.stroke();
                }
            }
            
            // Desenhar uma ligação no canvas 2D
            function drawBond2D(bond) {
                const atom1 = state.view2D.atoms.find(a => a.id === bond.atom1);
                const atom2 = state.view2D.atoms.find(a => a.id === bond.atom2);
                
                if (!atom1 || !atom2) return;
                
                const pos1 = worldToScreen(atom1.x, atom1.y);
                const pos2 = worldToScreen(atom2.x, atom2.y);
                
                // Calcular vetor da ligação
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Normalizar vetor
                const nx = dx / length;
                const ny = dy / length;
                
                // Vetor perpendicular
                const px = -ny;
                const py = nx;
                
                // Desenhar ligação com base na ordem
                ctx2D.strokeStyle = '#333333';
                
                if (bond.order === 1) {
                    // Ligação simples
                    ctx2D.lineWidth = 8;
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.stroke();
                } else if (bond.order === 2) {
                    // Ligação dupla
                    ctx2D.lineWidth = 6; // Espessura reduzida para ligações duplas
                    const offset = 6;
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x + px * offset, pos1.y + py * offset);
                    ctx2D.lineTo(pos2.x + px * offset, pos2.y + py * offset);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x - px * offset, pos1.y - py * offset);
                    ctx2D.lineTo(pos2.x - px * offset, pos2.y - py * offset);
                    ctx2D.stroke();
                } else if (bond.order === 3) {
                    // Ligação tripla
                    ctx2D.lineWidth = 5.5; // Espessura reduzida para ligações triplas
                    const offset = 8;
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x + px * offset, pos1.y + py * offset);
                    ctx2D.lineTo(pos2.x + px * offset, pos2.y + py * offset);
                    ctx2D.stroke();
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x - px * offset, pos1.y - py * offset);
                    ctx2D.lineTo(pos2.x - px * offset, pos2.y - py * offset);
                    ctx2D.stroke();
                }
            }
            
            // Desenhar a visualização 2D completa
            function draw2D() {
                // Limpar o canvas
                ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
                
                // Desenhar a grade
                drawGrid();
                
                // Desenhar ligações
                state.view2D.bonds.forEach(drawBond2D);
                
                // Desenhar átomos
                state.view2D.atoms.forEach(drawAtom2D);
                
                // Desenhar ligação temporária se estiver criando uma
                if (state.currentTool === 'bond' && state.isDrawing && state.view2D.selectedAtom) {
                    const pos1 = worldToScreen(state.view2D.selectedAtom.x, state.view2D.selectedAtom.y);
                    const pos2 = { x: state.view2D.mouseX, y: state.view2D.mouseY };
                    
                    ctx2D.beginPath();
                    ctx2D.moveTo(pos1.x, pos1.y);
                    ctx2D.lineTo(pos2.x, pos2.y);
                    ctx2D.strokeStyle = '#00ff00';
                    ctx2D.lineWidth = 3;
                    ctx2D.setLineDash([5, 5]);
                    ctx2D.stroke();
                    ctx2D.setLineDash([]);
                }
            }
            
            // Encontrar átomo na posição do mouse
            function findAtomAt(x, y) {
                const radius = 20; // Raio de detecção em pixels
                
                for (let i = state.view2D.atoms.length - 1; i >= 0; i--) {
                    const atom = state.view2D.atoms[i];
                    const pos = worldToScreen(atom.x, atom.y);
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= radius) {
                        return atom;
                    }
                }
                
                return null;
            }
            
            // Adicionar átomo na visualização 2D
            function addAtom2D(element, x, y) {
                // Aplicar snap à grade se necessário
                const pos = snapToGrid(x, y);
                
                // Criar novo átomo
                const atom = {
                    id: Date.now() + Math.random(), // ID único
                    element: element,
                    x: pos.x,
                    y: pos.y,
                    z: 0 // Z é zero na visualização 2D
                };
                
                // Adicionar ao array de átomos
                state.view2D.atoms.push(atom);
                
                // Redesenhar o canvas
                draw2D();
                
                return atom;
            }
            
            // Adicionar ligação na visualização 2D
            function addBond2D(atom1, atom2, order) {
                // Verificar se já existe uma ligação entre estes átomos
                const existingBond = state.view2D.bonds.find(bond => 
                    (bond.atom1 === atom1.id && bond.atom2 === atom2.id) ||
                    (bond.atom1 === atom2.id && bond.atom2 === atom1.id)
                );
                
                if (existingBond) {
                    // Atualizar ordem da ligação existente
                    existingBond.order = order;
                } else {
                    // Criar nova ligação
                    const bond = {
                        atom1: atom1.id,
                        atom2: atom2.id,
                        order: order
                    };
                    
                    // Adicionar ao array de ligações
                    state.view2D.bonds.push(bond);
                }
                
                // Redesenhar o canvas
                draw2D();
            }
            
            // Manipuladores de eventos para o canvas 2D
            function onCanvas2DMouseDown(event) {
                const rect = canvas2D.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Armazenar posição inicial para arrastar
                state.view2D.startX = x;
                state.view2D.startY = y;
                state.view2D.mouseX = x;
                state.view2D.mouseY = y;
                
                // Verificar se clicou em um átomo
                const atom = findAtomAt(x, y);
                
                if (atom) {
                    // Clicou em um átomo
                    if (state.currentTool === 'select') {
                        // Selecionar o átomo
                        state.view2D.selectedAtom = atom;
                        state.view2D.isDragging = true;
                        draw2D();
                    } else if (state.currentTool === 'bond') {
                        if (!state.view2D.selectedAtom) {
                            // Primeiro átomo da ligação
                            state.view2D.selectedAtom = atom;
                            state.isDrawing = true;
                        } else if (state.view2D.selectedAtom !== atom) {
                            // Segundo átomo da ligação - criar ligação
                            addBond2D(state.view2D.selectedAtom, atom, state.currentBond);
                            state.view2D.selectedAtom = null;
                            state.isDrawing = false;
                        }
                    } else if (state.currentTool === 'erase') {
                        // Remover átomo
                        const index = state.view2D.atoms.indexOf(atom);
                        if (index !== -1) {
                            // Remover ligações conectadas a este átomo
                            state.view2D.bonds = state.view2D.bonds.filter(bond => 
                                bond.atom1 !== atom.id && bond.atom2 !== atom.id
                            );
                            
                            // Remover o átomo
                            state.view2D.atoms.splice(index, 1);
                            
                            // Limpar seleção se necessário
                            if (state.view2D.selectedAtom === atom) {
                                state.view2D.selectedAtom = null;
                            }
                            
                            draw2D();
                        }
                    }
                } else {
                    // Clicou em um espaço vazio
                    if (state.currentTool === 'atom') {
                        // Adicionar novo átomo
                        const worldPos = screenToWorld(x, y);
                        const newAtom = addAtom2D(state.currentAtom, worldPos.x, worldPos.y);
                        
                        // Se estiver desenhando uma ligação, conectar ao átomo anterior
                        if (state.isDrawing && state.view2D.selectedAtom) {
                            addBond2D(state.view2D.selectedAtom, newAtom, state.currentBond);
                            state.view2D.selectedAtom = newAtom; // Continuar a partir do novo átomo
                        } else {
                            state.view2D.selectedAtom = newAtom;
                        }
                    } else if (state.currentTool === 'select') {
                        // Desselecionar átomo atual
                        state.view2D.selectedAtom = null;
                        
                        // Iniciar arrasto do canvas
                        state.view2D.isDragging = true;
                        draw2D();
                    } else if (state.currentTool === 'bond') {
                        // Cancelar seleção de ligação
                        state.view2D.selectedAtom = null;
                        state.isDrawing = false;
                        draw2D();
                    }
                }
            }
            
            function onCanvas2DMouseMove(event) {
                const rect = canvas2D.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Atualizar posição do mouse
                state.view2D.mouseX = x;
                state.view2D.mouseY = y;
                
                if (state.view2D.isDragging) {
                    if (state.view2D.selectedAtom) {
                        // Arrastar átomo selecionado
                        const worldPos = screenToWorld(x, y);
                        const snappedPos = snapToGrid(worldPos.x, worldPos.y);
                        
                        state.view2D.selectedAtom.x = snappedPos.x;
                        state.view2D.selectedAtom.y = snappedPos.y;
                    } else {
                        // Arrastar o canvas (pan)
                        const dx = x - state.view2D.startX;
                        const dy = y - state.view2D.startY;
                        
                        state.view2D.offsetX += dx;
                        state.view2D.offsetY += dy;
                        
                        state.view2D.startX = x;
                        state.view2D.startY = y;
                    }
                    
                    draw2D();
                } else if (state.isDrawing && state.currentTool === 'bond') {
                    // Desenhar linha temporária para ligação
                    draw2D();
                }
            }
            
            function onCanvas2DMouseUp(event) {
                state.view2D.isDragging = false;
                
                // Se estiver no modo bond, manter o estado de desenho
                if (state.currentTool !== 'bond') {
                    state.isDrawing = false;
                }
            }
            
            function onCanvas2DWheel(event) {
                event.preventDefault();
                
                // Calcular fator de zoom
                const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                
                // Posição do mouse em coordenadas do mundo antes do zoom
                const mousePos = screenToWorld(event.offsetX, event.offsetY);
                
                // Aplicar zoom
                state.view2D.scale *= zoomFactor;
                
                // Ajustar offset para manter o ponto sob o cursor
                const newMousePos = screenToWorld(event.offsetX, event.offsetY);
                state.view2D.offsetX += (newMousePos.x - mousePos.x) * state.view2D.scale;
                state.view2D.offsetY += (newMousePos.y - mousePos.y) * state.view2D.scale;
                
                draw2D();
            }
            
            // Funções para converter entre visualizações 2D e 3D
            
            // Converter moléculas 3D para 2D
            function convert3Dto2D() {
                // Limpar arrays 2D
                state.view2D.atoms = [];
                state.view2D.bonds = [];
                
                // Converter átomos
                molecules.atoms.forEach(atom => {
                    // Projetar coordenadas 3D para o plano XY
                    state.view2D.atoms.push({
                        id: atom.mesh.userData.atomIndex, // Usar o índice como ID
                        element: atom.element,
                        x: atom.position.x,
                        y: atom.position.y,
                        z: 0 // Ignorar coordenada Z para visualização 2D
                    });
                });
                
                // Converter ligações
                molecules.bonds.forEach(bond => {
                    state.view2D.bonds.push({
                        atom1: bond.atom1,
                        atom2: bond.atom2,
                        order: bond.order
                    });
                });
            }
            
            // Converter moléculas 2D para 3D
            function convert2Dto3D() {
                // Limpar a cena 3D
                clearMolecule();
                
                // Mapear IDs de átomos 2D para índices 3D
                const atomMap = new Map();
                
                // Adicionar átomos
                state.view2D.atoms.forEach(atom2D => {
                    // Criar átomo 3D com as coordenadas do átomo 2D
                    const index = addAtom(atom2D.element, atom2D.x, atom2D.y, 0);
                    atomMap.set(atom2D.id, index);
                });
                
                // Adicionar ligações
                state.view2D.bonds.forEach(bond2D => {
                    // Obter índices 3D correspondentes
                    const atom1Index = atomMap.get(bond2D.atom1);
                    const atom2Index = atomMap.get(bond2D.atom2);
                    
                    // Adicionar ligação 3D
                    if (atom1Index !== undefined && atom2Index !== undefined) {
                        addBond(atom1Index, atom2Index, bond2D.order);
                    }
                });
                
                // Otimizar a geometria para dar profundidade à molécula
                optimizeGeometry();
                
                // Atualizar contagens
                updateCounts();
            }
            
            // Função para verificar proximidade entre átomos e sugerir ligações
            function checkAtomProximity() {
                // Distâncias ideais para ligações entre diferentes elementos
                const bondDistances = {
                    'C-C': 1.5,
                    'C-H': 1.1,
                    'C-O': 1.4,
                    'C-N': 1.4,
                    'O-H': 1.0,
                    'N-H': 1.0,
                    'default': 1.5
                };
                
                // Tolerância para sugerir ligação
                const tolerance = 0.7; // 70% de tolerância
                
                // Limpar sugestões anteriores
                scene.children.forEach(obj => {
                    if (obj.userData && obj.userData.isSuggestion) {
                        scene.remove(obj);
                    }
                });
                
                // Só verificar se estiver no modo de ligação
                if (state.currentTool === 'bond') {
                    // Para cada par de átomos
                    for (let i = 0; i < molecules.atoms.length; i++) {
                        for (let j = i + 1; j < molecules.atoms.length; j++) {
                            const atom1 = molecules.atoms[i];
                            const atom2 = molecules.atoms[j];
                            
                            // Verificar se já existe ligação
                            const existingBond = molecules.bonds.find(b => 
                                (b.atom1 === i && b.atom2 === j) || 
                                (b.atom1 === j && b.atom2 === i)
                            );
                            
                            if (existingBond) continue;
                            
                            // Calcular distância
                            const distance = atom1.position.distanceTo(atom2.position);
                            
                            // Determinar distância ideal para esta combinação
                            const bondKey = `${atom1.element}-${atom2.element}`;
                            const reverseBondKey = `${atom2.element}-${atom1.element}`;
                            const idealDistance = bondDistances[bondKey] || 
                                                bondDistances[reverseBondKey] || 
                                                bondDistances.default;
                            
                            // Se estiver próximo o suficiente, sugerir ligação
                            const maxDistance = idealDistance * (1 + tolerance);
                            if (distance <= maxDistance) {
                                // Criar linha tracejada para sugerir ligação
                                const material = new THREE.LineDashedMaterial({
                                    color: 0x00ff00,
                                    dashSize: 0.1,
                                    gapSize: 0.05,
                                    opacity: 0.5,
                                    transparent: true
                                });
                                
                                const geometry = new THREE.BufferGeometry().setFromPoints([
                                    atom1.position,
                                    atom2.position
                                ]);
                                
                                const line = new THREE.Line(geometry, material);
                                line.computeLineDistances(); // Necessário para linhas tracejadas
                                line.userData = { 
                                    isSuggestion: true,
                                    atom1: i,
                                    atom2: j
                                };
                                scene.add(line);
                                
                                // Se o usuário clicar, criar a ligação
                                if (state.selectedAtoms.length === 1 && 
                                    (state.selectedAtoms[0] === i || state.selectedAtoms[0] === j)) {
                                    const otherAtom = state.selectedAtoms[0] === i ? j : i;
                                    addBond(state.selectedAtoms[0], otherAtom, state.currentBond);
                                    state.selectedAtoms = [];
                                    updateCounts();
                                }
                            }
                        }
                    }
                }
            }
            
            // Dados de geometria molecular baseados em hibridização
            const molecularGeometry = {
                // Ângulos de ligação em graus
                bondAngles: {
                    'sp3': 109.5,  // Tetraédrico (ex: C em metano)
                    'sp2': 120,    // Trigonal planar (ex: C em eteno)
                    'sp': 180,     // Linear (ex: C em etino)
                    'bent': {
                        'H2O': 104.5,  // Ângulo H-O-H na água
                        'NH3': 107,    // Ângulo H-N-H na amônia
                        'default': 109.5
                    }
                },
                
                // Comprimentos de ligação em Angstroms (convertidos para unidades Three.js)
                bondLengths: {
                    'C-C': 1.54,
                    'C=C': 1.34,
                    'C≡C': 1.20,
                    'C-H': 1.09,
                    'C-O': 1.43,
                    'C=O': 1.23,
                    'C-N': 1.47,
                    'C=N': 1.38,
                    'C≡N': 1.16,
                    'O-H': 0.96,
                    'N-H': 1.01,
                    'H-H': 0.74,
                    'O=O': 1.2,
                    'N≡N': 1.1,
                    'H-Cl': 1.3,
                    'default': 1.5
                },
                
                // Raios atômicos em Angstroms (convertidos para unidades Three.js)
                atomicRadii: {
                    'H': 0.25,
                    'C': 0.70,
                    'N': 0.65,
                    'O': 0.60,
                    'F': 0.50,
                    'P': 1.00,
                    'S': 1.00,
                    'Cl': 1.00,
                    'Br': 1.15,
                    'I': 1.40,
                    'default': 0.70
                }
            };
            
            // Parser de fórmulas químicas
            function parseChemicalFormula(formula) {
                // Remover espaços e normalizar
                formula = formula.trim().replace(/\s+/g, '');
                
                // Verificar se é uma fórmula conhecida dos presets
                const knownFormulas = {
                    'H2O': 'h2o',
                    'CO2': 'co2',
                    'CH4': 'ch4',
                    'NH3': 'nh3',
                    'C2H4': 'c2h4',
                    'C2H2': 'c2h2',
                    'O2': 'o2',
                    'N2': 'n2',
                    'HCl': 'hcl',
                    'HCL': 'hcl'
                };
                
                // Se for uma fórmula conhecida, usar o preset correspondente
                if (knownFormulas[formula]) {
                    loadMoleculePreset(knownFormulas[formula]);
                    return [];
                }
                
                // Expressão regular para identificar elementos e quantidades
                const elementRegex = /([A-Z][a-z]*)(\d*)/g;
                
                // Array para armazenar os elementos e suas quantidades
                const elements = [];
                let match;
                
                // Encontrar todos os elementos e suas quantidades
                while ((match = elementRegex.exec(formula)) !== null) {
                    const element = match[1];
                    const count = match[2] ? parseInt(match[2]) : 1;
                    elements.push({ element, count });
                }
                
                return elements;
            }
            
            // Determinar hibridização com base nas ligações
            function determineHybridization(element, bondCount) {
                if (element === 'C') {
                    if (bondCount === 4) return 'sp3';
                    if (bondCount === 3) return 'sp2';
                    if (bondCount === 2) return 'sp';
                } else if (element === 'N') {
                    if (bondCount === 3) return 'sp3';
                    if (bondCount === 2) return 'sp2';
                    if (bondCount === 1) return 'sp';
                } else if (element === 'O') {
                    if (bondCount === 2) return 'bent';
                    if (bondCount === 1) return 'sp3';
                }
                
                // Padrão para outros elementos
                return 'sp3';
            }
            
            // Construir molécula a partir de uma fórmula
            function buildMoleculeFromFormula(formula) {
                // Limpar molécula atual
                clearMolecule();
                
                // Mostrar overlay de carregamento
                loadingOverlay.classList.remove('hidden');
                
                // Parsear a fórmula
                const elements = parseChemicalFormula(formula);
                
                // Se parseChemicalFormula já carregou um preset, não precisamos fazer mais nada
                if (elements.length === 0) {
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Verificar se a fórmula é válida
                if (elements.length === 0) {
                    alert('Fórmula inválida. Por favor, insira uma fórmula química válida.');
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Tentar identificar moléculas conhecidas para estruturas específicas
                const knownMolecules = {
                    'H2O': buildWaterMolecule,
                    'NH3': buildAmmoniaMolecule,
                    'CH4': buildMethaneMolecule,
                    'C2H4': buildEtheneMolecule,
                    'C2H2': buildEthyneMolecule,
                    'C6H6': buildBenzeneMolecule,
                    'CO2': buildCarbonDioxideMolecule,
                    'O2': buildOxygenMolecule,
                    'N2': buildNitrogenMolecule,
                    'HCl': buildHydrogenChlorideMolecule
                };
                
                // Verificar se é uma molécula conhecida
                if (knownMolecules[formula]) {
                    knownMolecules[formula]();
                    loadingOverlay.classList.add('hidden');
                    return;
                }
                
                // Para moléculas desconhecidas, construir uma estrutura genérica
                buildGenericMolecule(elements);
                
                // Otimizar a geometria
                setTimeout(() => {
                    optimizeGeometry();
                    loadingOverlay.classList.add('hidden');
                }, 500);
            }
            
            // Construir moléculas conhecidas com geometria precisa
            
            // Água (H2O) - Geometria angular
            function buildWaterMolecule() {
                // Átomo de oxigênio no centro
                const oIndex = addAtom('O', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria angular (104.5°)
                const angle = molecularGeometry.bondAngles.bent.H2O * Math.PI / 180;
                const bondLength = molecularGeometry.bondLengths['O-H'];
                
                const h1Index = addAtom('H', bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                const h2Index = addAtom('H', -bondLength * Math.sin(angle/2), bondLength * Math.cos(angle/2), 0);
                
                // Adicionar ligações
                addBond(oIndex, h1Index, 1);
                addBond(oIndex, h2Index, 1);
                
                updateCounts();
            }
            
            // Amônia (NH3) - Geometria piramidal
            function buildAmmoniaMolecule() {
                // Átomo de nitrogênio no centro
                const nIndex = addAtom('N', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria piramidal (107°)
                const angle = molecularGeometry.bondAngles.bent.NH3 * Math.PI / 180;
                const bondLength = molecularGeometry.bondLengths['N-H'];
                
                // Calcular coordenadas para uma pirâmide trigonal
                const h1Index = addAtom('H', 0, bondLength * Math.cos(angle/2), bondLength * Math.sin(angle/2));
                const h2Index = addAtom('H', bondLength * Math.sin(angle/2) * Math.cos(2*Math.PI/3), 
                                        bondLength * Math.cos(angle/2), 
                                        bondLength * Math.sin(angle/2) * Math.sin(2*Math.PI/3));
                const h3Index = addAtom('H', bondLength * Math.sin(angle/2) * Math.cos(4*Math.PI/3), 
                                        bondLength * Math.cos(angle/2), 
                                        bondLength * Math.sin(angle/2) * Math.sin(4*Math.PI/3));
                
                // Adicionar ligações
                addBond(nIndex, h1Index, 1);
                addBond(nIndex, h2Index, 1);
                addBond(nIndex, h3Index, 1);
                
                updateCounts();
            }
            
            // Metano (CH4) - Geometria tetraédrica
            function buildMethaneMolecule() {
                // Átomo de carbono no centro
                const cIndex = addAtom('C', 0, 0, 0);
                
                // Átomos de hidrogênio em geometria tetraédrica (109.5°)
                const bondLength = molecularGeometry.bondLengths['C-H'];
                
                // Coordenadas para um tetraedro regular
                const tetrahedralCoords = [
                    new THREE.Vector3(bondLength, bondLength, bondLength),
                    new THREE.Vector3(-bondLength, -bondLength, bondLength),
                    new THREE.Vector3(-bondLength, bondLength, -bondLength),
                    new THREE.Vector3(bondLength, -bondLength, -bondLength)
                ];
                
                // Normalizar para o comprimento de ligação correto
                tetrahedralCoords.forEach(coord => coord.normalize().multiplyScalar(bondLength));
                
                // Adicionar átomos de hidrogênio
                const hIndices = tetrahedralCoords.map(coord => 
                    addAtom('H', coord.x, coord.y, coord.z)
                );
                
                // Adicionar ligações
                hIndices.forEach(hIndex => addBond(cIndex, hIndex, 1));
                
                updateCounts();
            }
            
            // Eteno (C2H4) - Geometria trigonal planar
            function buildEtheneMolecule() {
                // Comprimentos de ligação
                const ccLength = molecularGeometry.bondLengths['C=C'];
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono
                const c1Index = addAtom('C', -ccLength/2, 0, 0);
                const c2Index = addAtom('C', ccLength/2, 0, 0);
                
                // Átomos de hidrogênio para C1 (trigonal planar)
                const angle = molecularGeometry.bondAngles.sp2 * Math.PI / 180;
                const h1Index = addAtom('H', -ccLength/2 - chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                const h2Index = addAtom('H', -ccLength/2 - chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                
                // Átomos de hidrogênio para C2 (trigonal planar)
                const h3Index = addAtom('H', ccLength/2 + chLength * Math.cos(angle/2), chLength * Math.sin(angle/2), 0);
                const h4Index = addAtom('H', ccLength/2 + chLength * Math.cos(angle/2), -chLength * Math.sin(angle/2), 0);
                
                // Adicionar ligações
                addBond(c1Index, c2Index, 2); // Ligação dupla
                addBond(c1Index, h1Index, 1);
                addBond(c1Index, h2Index, 1);
                addBond(c2Index, h3Index, 1);
                addBond(c2Index, h4Index, 1);
                
                updateCounts();
            }
            
            // Etino (C2H2) - Geometria linear
            function buildEthyneMolecule() {
                // Comprimentos de ligação
                const ccLength = molecularGeometry.bondLengths['C≡C'];
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono
                const c1Index = addAtom('C', -ccLength/2, 0, 0);
                const c2Index = addAtom('C', ccLength/2, 0, 0);
                
                // Átomos de hidrogênio (linear)
                const h1Index = addAtom('H', -ccLength/2 - chLength, 0, 0);
                const h2Index = addAtom('H', ccLength/2 + chLength, 0, 0);
                
                // Adicionar ligações
                addBond(c1Index, c2Index, 3); // Ligação tripla
                addBond(c1Index, h1Index, 1);
                addBond(c2Index, h2Index, 1);
                
                updateCounts();
            }
            
            // Benzeno (C6H6) - Anel aromático
            function buildBenzeneMolecule() {
                // Raio do anel
                const radius = 1.4;
                const ccLength = molecularGeometry.bondLengths['C=C'] * 1.1; // Ligeiramente maior para aromaticidade
                const chLength = molecularGeometry.bondLengths['C-H'];
                
                // Átomos de carbono no anel
                const cIndices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const cIndex = addAtom('C', radius * Math.cos(angle), radius * Math.sin(angle), 0);
                    cIndices.push(cIndex);
                }
                
                // Átomos de hidrogênio
                const hIndices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const hIndex = addAtom('H', (radius + chLength) * Math.cos(angle), (radius + chLength) * Math.sin(angle), 0);
                    hIndices.push(hIndex);
                }
                
                // Adicionar ligações no anel (alternando simples e duplas)
                for (let i = 0; i < 6; i++) {
                    const j = (i + 1) % 6;
                    addBond(cIndices[i], cIndices[j], i % 2 === 0 ? 2 : 1);
                }
                
                // Adicionar ligações C-H
                for (let i = 0; i < 6; i++) {
                    addBond(cIndices[i], hIndices[i], 1);
                }
                
                updateCounts();
            }
            
            // Dióxido de carbono (CO2) - Geometria linear
            function buildCarbonDioxideMolecule() {
                // Comprimento de ligação
                const coLength = molecularGeometry.bondLengths['C=O'];
                
                // Átomos
                const cIndex = addAtom('C', 0, 0, 0);
                const o1Index = addAtom('O', -coLength, 0, 0);
                const o2Index = addAtom('O', coLength, 0, 0);
                
                // Adicionar ligações duplas
                addBond(cIndex, o1Index, 2);
                addBond(cIndex, o2Index, 2);
                
                updateCounts();
            }
            
            // Oxigênio (O2) - Geometria linear
            function buildOxygenMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['O=O'] || 1.2;
                
                // Átomos
                const o1Index = addAtom('O', -bondLength/2, 0, 0);
                const o2Index = addAtom('O', bondLength/2, 0, 0);
                
                // Adicionar ligação dupla
                addBond(o1Index, o2Index, 2);
                
                updateCounts();
            }
            
            // Nitrogênio (N2) - Geometria linear
            function buildNitrogenMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['N≡N'] || 1.1;
                
                // Átomos
                const n1Index = addAtom('N', -bondLength/2, 0, 0);
                const n2Index = addAtom('N', bondLength/2, 0, 0);
                
                // Adicionar ligação tripla
                addBond(n1Index, n2Index, 3);
                
                updateCounts();
            }
            
            // Ácido Clorídrico (HCl) - Geometria linear
            function buildHydrogenChlorideMolecule() {
                // Comprimento de ligação
                const bondLength = molecularGeometry.bondLengths['H-Cl'] || 1.3;
                
                // Átomos
                const hIndex = addAtom('H', -bondLength/2, 0, 0);
                const clIndex = addAtom('Cl', bondLength/2, 0, 0);
                
                // Adicionar ligação simples
                addBond(hIndex, clIndex, 1);
                
                updateCounts();
            }
            
            // Construir molécula genérica para fórmulas desconhecidas
            function buildGenericMolecule(elements) {
                // Posicionar o primeiro elemento no centro
                let centralElement = elements[0].element;
                let centralIndex = addAtom(centralElement, 0, 0, 0);
                
                // Posicionar os outros elementos ao redor do central
                let angleStep = 2 * Math.PI / (elements.length - 1);
                let radius = 1.5; // Distância padrão
                
                for (let i = 1; i < elements.length; i++) {
                    const element = elements[i].element;
                    const count = elements[i].count;
                    
                    // Determinar comprimento de ligação
                    const bondKey = `${centralElement}-${element}`;
                    const reverseBondKey = `${element}-${centralElement}`;
                    const bondLength = molecularGeometry.bondLengths[bondKey] || 
                                      molecularGeometry.bondLengths[reverseBondKey] || 
                                      molecularGeometry.bondLengths.default;
                    
                    // Adicionar átomos em círculo
                    for (let j = 0; j < count; j++) {
                        const angle = angleStep * (i-1) + (j * 2 * Math.PI / count);
                        const x = bondLength * Math.cos(angle);
                        const y = bondLength * Math.sin(angle);
                        const z = 0;
                        
                        const atomIndex = addAtom(element, x, y, z);
                        addBond(centralIndex, atomIndex, 1);
                    }
                }
                
                updateCounts();
            }
            
            // Event listener para o botão de parsear fórmula
            parseFormulaBtn.addEventListener('click', () => {
                const formula = formulaInput.value.trim();
                if (formula) {
                    buildMoleculeFromFormula(formula);
                }
            });
            
            // Event listener para tecla Enter no campo de fórmula
            formulaInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const formula = formulaInput.value.trim();
                    if (formula) {
                        buildMoleculeFromFormula(formula);
                    }
                }
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                
                // Verificar proximidade entre átomos para sugerir ligações
                checkAtomProximity();
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            animate();
            
            // Initial setup
            setActiveTool('select');
            updateCounts();
            
            // Load water molecule by default
            loadMoleculePreset('h2o');
            
            // Recriar todas as legendas com o novo sistema centralizado
            recreateAllAtomLabels();
        });
    </script>
</body>
</html>
